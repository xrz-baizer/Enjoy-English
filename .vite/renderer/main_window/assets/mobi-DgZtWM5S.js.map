{"version":3,"file":"mobi-DgZtWM5S.js","sources":["../../../../node_modules/foliate-js/mobi.js"],"sourcesContent":["const unescapeHTML = str => {\n    if (!str) return ''\n    const textarea = document.createElement('textarea')\n    textarea.innerHTML = str\n    return textarea.value\n}\n\nconst MIME = {\n    XML: 'application/xml',\n    XHTML: 'application/xhtml+xml',\n    HTML: 'text/html',\n    CSS: 'text/css',\n    SVG: 'image/svg+xml',\n}\n\nconst PDB_HEADER = {\n    name: [0, 32, 'string'],\n    type: [60, 4, 'string'],\n    creator: [64, 4, 'string'],\n    numRecords: [76, 2, 'uint'],\n}\n\nconst PALMDOC_HEADER = {\n    compression: [0, 2, 'uint'],\n    numTextRecords: [8, 2, 'uint'],\n    recordSize: [10, 2, 'uint'],\n    encryption: [12, 2, 'uint'],\n}\n\nconst MOBI_HEADER = {\n    magic: [16, 4, 'string'],\n    length: [20, 4, 'uint'],\n    type: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    uid: [32, 4, 'uint'],\n    version: [36, 4, 'uint'],\n    titleOffset: [84, 4, 'uint'],\n    titleLength: [88, 4, 'uint'],\n    localeRegion: [94, 1, 'uint'],\n    localeLanguage: [95, 1, 'uint'],\n    resourceStart: [108, 4, 'uint'],\n    huffcdic: [112, 4, 'uint'],\n    numHuffcdic: [116, 4, 'uint'],\n    exthFlag: [128, 4, 'uint'],\n    trailingFlags: [240, 4, 'uint'],\n    indx: [244, 4, 'uint'],\n}\n\nconst KF8_HEADER = {\n    resourceStart: [108, 4, 'uint'],\n    fdst: [192, 4, 'uint'],\n    numFdst: [196, 4, 'uint'],\n    frag: [248, 4, 'uint'],\n    skel: [252, 4, 'uint'],\n    guide: [260, 4, 'uint'],\n}\n\nconst EXTH_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    count: [8, 4, 'uint'],\n}\n\nconst INDX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    type: [8, 4, 'uint'],\n    idxt: [20, 4, 'uint'],\n    numRecords: [24, 4, 'uint'],\n    encoding: [28, 4, 'uint'],\n    language: [32, 4, 'uint'],\n    total: [36, 4, 'uint'],\n    ordt: [40, 4, 'uint'],\n    ligt: [44, 4, 'uint'],\n    numLigt: [48, 4, 'uint'],\n    numCncx: [52, 4, 'uint'],\n}\n\nconst TAGX_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numControlBytes: [8, 4, 'uint'],\n}\n\nconst HUFF_HEADER = {\n    magic: [0, 4, 'string'],\n    offset1: [8, 4, 'uint'],\n    offset2: [12, 4, 'uint'],\n}\n\nconst CDIC_HEADER = {\n    magic: [0, 4, 'string'],\n    length: [4, 4, 'uint'],\n    numEntries: [8, 4, 'uint'],\n    codeLength: [12, 4, 'uint'],\n}\n\nconst FDST_HEADER = {\n    magic: [0, 4, 'string'],\n    numEntries: [8, 4, 'uint'],\n}\n\nconst FONT_HEADER = {\n    flags: [8, 4, 'uint'],\n    dataStart: [12, 4, 'uint'],\n    keyLength: [16, 4, 'uint'],\n    keyStart: [20, 4, 'uint'],\n}\n\nconst MOBI_ENCODING = {\n    1252: 'windows-1252',\n    65001: 'utf-8',\n}\n\nconst EXTH_RECORD_TYPE = {\n    100: ['creator', 'string', true],\n    101: ['publisher'],\n    103: ['description'],\n    104: ['isbn'],\n    105: ['subject', 'string', true],\n    106: ['date'],\n    108: ['contributor', 'string', true],\n    109: ['rights'],\n    110: ['subjectCode', 'string', true],\n    112: ['source', 'string', true],\n    113: ['asin'],\n    121: ['boundary', 'uint'],\n    122: ['fixedLayout'],\n    125: ['numResources', 'uint'],\n    126: ['originalResolution'],\n    127: ['zeroGutter'],\n    128: ['zeroMargin'],\n    129: ['coverURI'],\n    132: ['regionMagnification'],\n    201: ['coverOffset', 'uint'],\n    202: ['thumbnailOffset', 'uint'],\n    503: ['title'],\n    524: ['language', 'string', true],\n    527: ['pageProgressionDirection'],\n}\n\nconst MOBI_LANG = {\n    1: ['ar', 'ar-SA', 'ar-IQ', 'ar-EG', 'ar-LY', 'ar-DZ', 'ar-MA', 'ar-TN', 'ar-OM',\n        'ar-YE', 'ar-SY', 'ar-JO', 'ar-LB', 'ar-KW', 'ar-AE', 'ar-BH', 'ar-QA'],\n    2: ['bg'], 3: ['ca'], 4: ['zh', 'zh-TW', 'zh-CN', 'zh-HK', 'zh-SG'], 5: ['cs'],\n    6: ['da'], 7: ['de', 'de-DE', 'de-CH', 'de-AT', 'de-LU', 'de-LI'], 8: ['el'],\n    9: ['en', 'en-US', 'en-GB', 'en-AU', 'en-CA', 'en-NZ', 'en-IE', 'en-ZA',\n        'en-JM', null, 'en-BZ', 'en-TT', 'en-ZW', 'en-PH'],\n    10: ['es', 'es-ES', 'es-MX', null, 'es-GT', 'es-CR', 'es-PA', 'es-DO',\n        'es-VE', 'es-CO', 'es-PE', 'es-AR', 'es-EC', 'es-CL', 'es-UY', 'es-PY',\n        'es-BO', 'es-SV', 'es-HN', 'es-NI', 'es-PR'],\n    11: ['fi'], 12: ['fr', 'fr-FR', 'fr-BE', 'fr-CA', 'fr-CH', 'fr-LU', 'fr-MC'],\n    13: ['he'], 14: ['hu'], 15: ['is'], 16: ['it', 'it-IT', 'it-CH'],\n    17: ['ja'], 18: ['ko'], 19: ['nl', 'nl-NL', 'nl-BE'], 20: ['no', 'nb', 'nn'],\n    21: ['pl'], 22: ['pt', 'pt-BR', 'pt-PT'], 23: ['rm'], 24: ['ro'], 25: ['ru'],\n    26: ['hr', null, 'sr'], 27: ['sk'], 28: ['sq'], 29: ['sv', 'sv-SE', 'sv-FI'],\n    30: ['th'], 31: ['tr'], 32: ['ur'], 33: ['id'], 34: ['uk'], 35: ['be'],\n    36: ['sl'], 37: ['et'], 38: ['lv'], 39: ['lt'], 41: ['fa'], 42: ['vi'],\n    43: ['hy'], 44: ['az'], 45: ['eu'], 46: ['hsb'], 47: ['mk'], 48: ['st'],\n    49: ['ts'], 50: ['tn'], 52: ['xh'], 53: ['zu'], 54: ['af'], 55: ['ka'],\n    56: ['fo'], 57: ['hi'], 58: ['mt'], 59: ['se'], 62: ['ms'], 63: ['kk'],\n    65: ['sw'], 67: ['uz', null, 'uz-UZ'], 68: ['tt'], 69: ['bn'], 70: ['pa'],\n    71: ['gu'], 72: ['or'], 73: ['ta'], 74: ['te'], 75: ['kn'], 76: ['ml'],\n    77: ['as'], 78: ['mr'], 79: ['sa'], 82: ['cy', 'cy-GB'], 83: ['gl', 'gl-ES'],\n    87: ['kok'], 97: ['ne'], 98: ['fy'],\n}\n\nconst concatTypedArray = (a, b) => {\n    const result = new a.constructor(a.length + b.length)\n    result.set(a)\n    result.set(b, a.length)\n    return result\n}\nconst concatTypedArray3 = (a, b, c) => {\n    const result = new a.constructor(a.length + b.length + c.length)\n    result.set(a)\n    result.set(b, a.length)\n    result.set(c, a.length + b.length)\n    return result\n}\n\nconst decoder = new TextDecoder()\nconst getString = buffer => decoder.decode(buffer)\nconst getUint = buffer => {\n    if (!buffer) return\n    const l = buffer.byteLength\n    const func = l === 4 ? 'getUint32' : l === 2 ? 'getUint16' : 'getUint8'\n    return new DataView(buffer)[func](0)\n}\nconst getStruct = (def, buffer) => Object.fromEntries(Array.from(Object.entries(def))\n    .map(([key, [start, len, type]]) => [key,\n        (type === 'string' ? getString : getUint)(buffer.slice(start, start + len))]))\n\nconst getDecoder = x => new TextDecoder(MOBI_ENCODING[x])\n\nconst getVarLen = (byteArray, i = 0) => {\n    let value = 0, length = 0\n    for (const byte of byteArray.subarray(i, i + 4)) {\n        value = (value << 7) | (byte & 0b111_1111) >>> 0\n        length++\n        if (byte & 0b1000_0000) break\n    }\n    return { value, length }\n}\n\n// variable-length quantity, but read from the end of data\nconst getVarLenFromEnd = byteArray => {\n    let value = 0\n    for (const byte of byteArray.subarray(-4)) {\n        // `byte & 0b1000_0000` indicates the start of value\n        if (byte & 0b1000_0000) value = 0\n        value = (value << 7) | (byte & 0b111_1111)\n    }\n    return value\n}\n\nconst countBitsSet = x => {\n    let count = 0\n    for (; x > 0; x = x >> 1) if ((x & 1) === 1) count++\n    return count\n}\n\nconst countUnsetEnd = x => {\n    let count = 0\n    while ((x & 1) === 0) x = x >> 1, count++\n    return count\n}\n\nconst decompressPalmDOC = array => {\n    let output = []\n    for (let i = 0; i < array.length; i++) {\n        const byte = array[i]\n        if (byte === 0) output.push(0) // uncompressed literal, just copy it\n        else if (byte <= 8) // copy next 1-8 bytes\n            for (const x of array.subarray(i + 1, (i += byte) + 1))\n                output.push(x)\n        else if (byte <= 0b0111_1111) output.push(byte) // uncompressed literal\n        else if (byte <= 0b1011_1111) {\n            // 1st and 2nd bits are 10, meaning this is a length-distance pair\n            // read next byte and combine it with current byte\n            const bytes = (byte << 8) | array[i++ + 1]\n            // the 3rd to 13th bits encode distance\n            const distance = (bytes & 0b0011_1111_1111_1111) >>> 3\n            // the last 3 bits, plus 3, is the length to copy\n            const length = (bytes & 0b111) + 3\n            for (let j = 0; j < length; j++)\n                output.push(output[output.length - distance])\n        }\n        // compressed from space plus char\n        else output.push(32, byte ^ 0b1000_0000)\n    }\n    return Uint8Array.from(output)\n}\n\nconst read32Bits = (byteArray, from) => {\n    const startByte = from >> 3\n    const end = from + 32\n    const endByte = end >> 3\n    let bits = 0n\n    for (let i = startByte; i <= endByte; i++)\n        bits = bits << 8n | BigInt(byteArray[i] ?? 0)\n    return (bits >> (8n - BigInt(end & 7))) & 0xffffffffn\n}\n\nconst huffcdic = async (mobi, loadRecord) => {\n    const huffRecord = await loadRecord(mobi.huffcdic)\n    const { magic, offset1, offset2 } = getStruct(HUFF_HEADER, huffRecord)\n    if (magic !== 'HUFF') throw new Error('Invalid HUFF record')\n\n    // table1 is indexed by byte value\n    const table1 = Array.from({ length: 256 }, (_, i) => offset1 + i * 4)\n        .map(offset => getUint(huffRecord.slice(offset, offset + 4)))\n        .map(x => [x & 0b1000_0000, x & 0b1_1111, x >>> 8])\n\n    // table2 is indexed by code length\n    const table2 = [null].concat(Array.from({ length: 32 }, (_, i) => offset2 + i * 8)\n        .map(offset => [\n            getUint(huffRecord.slice(offset, offset + 4)),\n            getUint(huffRecord.slice(offset + 4, offset + 8))]))\n\n    const dictionary = []\n    for (let i = 1; i < mobi.numHuffcdic; i++) {\n        const record = await loadRecord(mobi.huffcdic + i)\n        const cdic = getStruct(CDIC_HEADER, record)\n        if (cdic.magic !== 'CDIC') throw new Error('Invalid CDIC record')\n        // `numEntries` is the total number of dictionary data across CDIC records\n        // so `n` here is the number of entries in *this* record\n        const n = Math.min(1 << cdic.codeLength, cdic.numEntries - dictionary.length)\n        const buffer = record.slice(cdic.length)\n        for (let i = 0; i < n; i++) {\n            const offset = getUint(buffer.slice(i * 2, i * 2 + 2))\n            const x = getUint(buffer.slice(offset, offset + 2))\n            const length = x & 0x7fff\n            const decompressed = x & 0x8000\n            const value = new Uint8Array(\n                buffer.slice(offset + 2, offset + 2 + length))\n            dictionary.push([value, decompressed])\n        }\n    }\n\n    const decompress = byteArray => {\n        let output = new Uint8Array()\n        const bitLength = byteArray.byteLength * 8\n        for (let i = 0; i < bitLength;) {\n            const bits = Number(read32Bits(byteArray, i))\n            let [found, codeLength, value] = table1[bits >>> 24]\n            if (!found) {\n                while (bits >>> (32 - codeLength) < table2[codeLength][0])\n                    codeLength += 1\n                value = table2[codeLength][1]\n            }\n            if ((i += codeLength) > bitLength) break\n\n            const code = value - (bits >>> (32 - codeLength))\n            let [result, decompressed] = dictionary[code]\n            if (!decompressed) {\n                // the result is itself compressed\n                result = decompress(result)\n                // cache the result for next time\n                dictionary[code] = [result, true]\n            }\n            output = concatTypedArray(output, result)\n        }\n        return output\n    }\n    return decompress\n}\n\nconst getIndexData = async (indxIndex, loadRecord) => {\n    const indxRecord = await loadRecord(indxIndex)\n    const indx = getStruct(INDX_HEADER, indxRecord)\n    if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n    const decoder = getDecoder(indx.encoding)\n\n    const tagxBuffer = indxRecord.slice(indx.length)\n    const tagx = getStruct(TAGX_HEADER, tagxBuffer)\n    if (tagx.magic !== 'TAGX') throw new Error('Invalid TAGX section')\n    const numTags = (tagx.length - 12) / 4\n    const tagTable = Array.from({ length: numTags }, (_, i) =>\n        new Uint8Array(tagxBuffer.slice(12 + i * 4, 12 + i * 4 + 4)))\n\n    const cncx = {}\n    let cncxRecordOffset = 0\n    for (let i = 0; i < indx.numCncx; i++) {\n        const record = await loadRecord(indxIndex + indx.numRecords + i + 1)\n        const array = new Uint8Array(record)\n        for (let pos = 0; pos < array.byteLength;) {\n            const index = pos\n            const { value, length } = getVarLen(array, pos)\n            pos += length\n            const result = record.slice(pos, pos + value)\n            pos += value\n            cncx[cncxRecordOffset + index] = decoder.decode(result)\n        }\n        cncxRecordOffset += 0x10000\n    }\n\n    const table = []\n    for (let i = 0; i < indx.numRecords; i++) {\n        const record = await loadRecord(indxIndex + 1 + i)\n        const array = new Uint8Array(record)\n        const indx = getStruct(INDX_HEADER, record)\n        if (indx.magic !== 'INDX') throw new Error('Invalid INDX record')\n        for (let j = 0; j < indx.numRecords; j++) {\n            const offsetOffset = indx.idxt + 4 + 2 * j\n            const offset = getUint(record.slice(offsetOffset, offsetOffset + 2))\n\n            const length = getUint(record.slice(offset, offset + 1))\n            const name = getString(record.slice(offset + 1, offset + 1 + length))\n\n            const tags = []\n            const startPos = offset + 1 + length\n            let controlByteIndex = 0\n            let pos = startPos + tagx.numControlBytes\n            for (const [tag, numValues, mask, end] of tagTable) {\n                if (end & 1) {\n                    controlByteIndex++\n                    continue\n                }\n                const offset = startPos + controlByteIndex\n                const value = getUint(record.slice(offset, offset + 1)) & mask\n                if (value === mask) {\n                    if (countBitsSet(mask) > 1) {\n                        const { value, length } = getVarLen(array, pos)\n                        tags.push([tag, null, value, numValues])\n                        pos += length\n                    } else tags.push([tag, 1, null, numValues])\n                } else tags.push([tag, value >> countUnsetEnd(mask), null, numValues])\n            }\n\n            const tagMap = {}\n            for (const [tag, valueCount, valueBytes, numValues] of tags) {\n                const values = []\n                if (valueCount != null) {\n                    for (let i = 0; i < valueCount * numValues; i++) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                    }\n                } else {\n                    let count = 0\n                    while (count < valueBytes) {\n                        const { value, length } = getVarLen(array, pos)\n                        values.push(value)\n                        pos += length\n                        count += length\n                    }\n                }\n                tagMap[tag] = values\n            }\n            table.push({ name, tagMap })\n        }\n    }\n    return { table, cncx }\n}\n\nconst getNCX = async (indxIndex, loadRecord) => {\n    const { table, cncx } = await getIndexData(indxIndex, loadRecord)\n    const items = table.map(({ tagMap }, index) => ({\n        index,\n        offset: tagMap[1]?.[0],\n        size: tagMap[2]?.[0],\n        label: cncx[tagMap[3]] ?? '',\n        headingLevel: tagMap[4]?.[0],\n        pos: tagMap[6],\n        parent: tagMap[21]?.[0],\n        firstChild: tagMap[22]?.[0],\n        lastChild: tagMap[23]?.[0],\n    }))\n    const getChildren = item => {\n        if (item.firstChild == null) return item\n        item.children = items.filter(x => x.parent === item.index).map(getChildren)\n        return item\n    }\n    return items.filter(item => item.headingLevel === 0).map(getChildren)\n}\n\nconst getEXTH = (buf, encoding) => {\n    const { magic, count } = getStruct(EXTH_HEADER, buf)\n    if (magic !== 'EXTH') throw new Error('Invalid EXTH header')\n    const decoder = getDecoder(encoding)\n    const results = {}\n    let offset = 12\n    for (let i = 0; i < count; i++) {\n        const type = getUint(buf.slice(offset, offset + 4))\n        const length = getUint(buf.slice(offset + 4, offset + 8))\n        if (type in EXTH_RECORD_TYPE) {\n            const [name, typ, many] = EXTH_RECORD_TYPE[type]\n            const data = buf.slice(offset + 8, offset + length)\n            const value = typ === 'uint' ? getUint(data) : decoder.decode(data)\n            if (many) {\n                results[name] ??= []\n                results[name].push(value)\n            } else results[name] = value\n        }\n        offset += length\n    }\n    return results\n}\n\nconst getFont = async (buf, unzlib) => {\n    const { flags, dataStart, keyLength, keyStart } = getStruct(FONT_HEADER, buf)\n    const array = new Uint8Array(buf.slice(dataStart))\n    // deobfuscate font\n    if (flags & 0b10) {\n        const bytes = keyLength === 16 ? 1024 : 1040\n        const key = new Uint8Array(buf.slice(keyStart, keyStart + keyLength))\n        const length = Math.min(bytes, array.length)\n        for (var i = 0; i < length; i++) array[i] = array[i] ^ key[i % key.length]\n    }\n    // decompress font\n    if (flags & 1) try {\n        return await unzlib(array)\n    } catch (e) {\n        console.warn(e)\n        console.warn('Failed to decompress font')\n    }\n    return array\n}\n\nexport const isMOBI = async file => {\n    const magic = getString(await file.slice(60, 68).arrayBuffer())\n    return magic === 'BOOKMOBI'// || magic === 'TEXtREAd'\n}\n\nclass PDB {\n    #file\n    #offsets\n    pdb\n    async open(file) {\n        this.#file = file\n        const pdb = getStruct(PDB_HEADER, await file.slice(0, 78).arrayBuffer())\n        this.pdb = pdb\n        const buffer = await file.slice(78, 78 + pdb.numRecords * 8).arrayBuffer()\n        // get start and end offsets for each record\n        this.#offsets = Array.from({ length: pdb.numRecords },\n            (_, i) => getUint(buffer.slice(i * 8, i * 8 + 4)))\n            .map((x, i, a) => [x, a[i + 1]])\n    }\n    loadRecord(index) {\n        const offsets = this.#offsets[index]\n        if (!offsets) throw new RangeError('Record index out of bounds')\n        return this.#file.slice(...offsets).arrayBuffer()\n    }\n    async loadMagic(index) {\n        const start = this.#offsets[index][0]\n        return getString(await this.#file.slice(start, start + 4).arrayBuffer())\n    }\n}\n\nexport class MOBI extends PDB {\n    #start = 0\n    #resourceStart\n    #decoder\n    #encoder\n    #decompress\n    #removeTrailingEntries\n    constructor({ unzlib }) {\n        super()\n        this.unzlib = unzlib\n    }\n    async open(file) {\n        await super.open(file)\n        // TODO: if (this.pdb.type === 'TEXt')\n        this.headers = this.#getHeaders(await super.loadRecord(0))\n        this.#resourceStart = this.headers.mobi.resourceStart\n        let isKF8 = this.headers.mobi.version >= 8\n        if (!isKF8) {\n            const boundary = this.headers.exth?.boundary\n            if (boundary < 0xffffffff) try {\n                // it's a \"combo\" MOBI/KF8 file; try to open the KF8 part\n                this.headers = this.#getHeaders(await super.loadRecord(boundary))\n                this.#start = boundary\n                isKF8 = true\n            } catch (e) {\n                console.warn(e)\n                console.warn('Failed to open KF8; falling back to MOBI')\n            }\n        }\n        await this.#setup()\n        return isKF8 ? new KF8(this).init() : new MOBI6(this).init()\n    }\n    #getHeaders(buf) {\n        const palmdoc = getStruct(PALMDOC_HEADER, buf)\n        const mobi = getStruct(MOBI_HEADER, buf)\n        if (mobi.magic !== 'MOBI') throw new Error('Missing MOBI header')\n\n        const { titleOffset, titleLength, localeLanguage, localeRegion } = mobi\n        mobi.title = buf.slice(titleOffset, titleOffset + titleLength)\n        const lang = MOBI_LANG[localeLanguage]\n        mobi.language = lang?.[localeRegion >> 2] ?? lang?.[0]\n\n        const exth = mobi.exthFlag & 0b100_0000\n            ? getEXTH(buf.slice(mobi.length + 16), mobi.encoding) : null\n        const kf8 = mobi.version >= 8 ? getStruct(KF8_HEADER, buf) : null\n        return { palmdoc, mobi, exth, kf8 }\n    }\n    async #setup() {\n        const { palmdoc, mobi } = this.headers\n        this.#decoder = getDecoder(mobi.encoding)\n        // `TextEncoder` only supports UTF-8\n        // we are only encoding ASCII anyway, so I think it's fine\n        this.#encoder = new TextEncoder()\n\n        // set up decompressor\n        const { compression } = palmdoc\n        this.#decompress = compression === 1 ? f => f\n            : compression === 2 ? decompressPalmDOC\n            : compression === 17480 ? await huffcdic(mobi, this.loadRecord.bind(this))\n            : null\n        if (!this.#decompress) throw new Error('Unknown compression type')\n\n        // set up function for removing trailing bytes\n        const { trailingFlags } = mobi\n        const multibyte = trailingFlags & 1\n        const numTrailingEntries = countBitsSet(trailingFlags >>> 1)\n        this.#removeTrailingEntries = array => {\n            for (let i = 0; i < numTrailingEntries; i++) {\n                const length = getVarLenFromEnd(array)\n                array = array.subarray(0, -length)\n            }\n            if (multibyte) {\n                const length = (array[array.length - 1] & 0b11) + 1\n                array = array.subarray(0, -length)\n            }\n            return array\n        }\n    }\n    decode(...args) {\n        return this.#decoder.decode(...args)\n    }\n    encode(...args) {\n        return this.#encoder.encode(...args)\n    }\n    loadRecord(index) {\n        return super.loadRecord(this.#start + index)\n    }\n    loadMagic(index) {\n        return super.loadMagic(this.#start + index)\n    }\n    loadText(index) {\n        return this.loadRecord(index + 1)\n            .then(buf => new Uint8Array(buf))\n            .then(this.#removeTrailingEntries)\n            .then(this.#decompress)\n    }\n    async loadResource(index) {\n        const buf = await super.loadRecord(this.#resourceStart + index)\n        const magic = getString(buf.slice(0, 4))\n        if (magic === 'FONT') return getFont(buf, this.unzlib)\n        if (magic === 'VIDE' || magic === 'AUDI') return buf.slice(12)\n        return buf\n    }\n    getNCX() {\n        const index = this.headers.mobi.indx\n        if (index < 0xffffffff) return getNCX(index, this.loadRecord.bind(this))\n    }\n    getMetadata() {\n        const { mobi, exth } = this.headers\n        return {\n            identifier: mobi.uid.toString(),\n            title: unescapeHTML(exth?.title || this.decode(mobi.title)),\n            author: exth?.creator?.map(unescapeHTML),\n            publisher: unescapeHTML(exth?.publisher),\n            language: exth?.language ?? mobi.language,\n            published: exth?.date,\n            description: unescapeHTML(exth?.description),\n            subject: exth?.subject?.map(unescapeHTML),\n            rights: unescapeHTML(exth?.rights),\n            contributor: exth?.contributor,\n        }\n    }\n    async getCover() {\n        const { exth } = this.headers\n        const offset = exth?.coverOffset < 0xffffffff ? exth?.coverOffset\n            : exth?.thumbnailOffset < 0xffffffff ? exth?.thumbnailOffset : null\n        if (offset != null) {\n            const buf = await this.loadResource(offset)\n            return new Blob([buf])\n        }\n    }\n}\n\nconst mbpPagebreakRegex = /<\\s*(?:mbp:)?pagebreak[^>]*>/gi\nconst fileposRegex = /<[^<>]+filepos=['\"]{0,1}(\\d+)[^<>]*>/gi\n\nconst getIndent = el => {\n    let x = 0\n    while (el) {\n        const parent = el.parentElement\n        if (parent) {\n            const tag = parent.tagName.toLowerCase()\n            if (tag === 'p') x += 1.5\n            else if (tag === 'blockquote') x += 2\n        }\n        el = parent\n    }\n    return x\n}\n\nclass MOBI6 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    #resourceCache = new Map()\n    #textCache = new Map()\n    #cache = new Map()\n    #sections\n    #fileposList = []\n    #type = MIME.HTML\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        // load all text records in an array\n        let array = new Uint8Array()\n        for (let i = 0; i < this.mobi.headers.palmdoc.numTextRecords; i++)\n            array = concatTypedArray(array, await this.mobi.loadText(i))\n\n        // convert to string so we can use regex\n        // note that `filepos` are byte offsets\n        // so it needs to preserve each byte as a separate character\n        // (see https://stackoverflow.com/q/50198017)\n        const str = Array.from(new Uint8Array(array),\n            c => String.fromCharCode(c)).join('')\n\n        // split content into sections at each `<mbp:pagebreak>`\n        this.#sections = [0]\n            .concat(Array.from(str.matchAll(mbpPagebreakRegex), m => m.index))\n            .map((x, i, a) => str.slice(x, a[i + 1]))\n            // recover the original raw bytes\n            .map(str => Uint8Array.from(str, x => x.charCodeAt(0)))\n            .map(raw => ({ book: this, raw }))\n            // get start and end filepos for each section\n            .reduce((arr, x) => {\n                const last = arr[arr.length - 1]\n                x.start = last?.end ?? 0\n                x.end = x.start + x.raw.byteLength\n                return arr.concat(x)\n            }, [])\n\n        this.sections = this.#sections.map((section, index) => ({\n            id: index,\n            load: () => this.loadSection(section),\n            createDocument: () => this.createDocument(section),\n            size: section.end - section.start,\n        }))\n\n        try {\n            this.landmarks = await this.getGuide()\n            const tocHref = this.landmarks\n                .find(({ type }) => type?.includes('toc'))?.href\n            if (tocHref) {\n                const { index } = this.resolveHref(tocHref)\n                const doc = await this.sections[index].createDocument()\n                let lastItem\n                let lastLevel = 0\n                let lastIndent = 0\n                const lastLevelOfIndent = new Map()\n                const lastParentOfLevel = new Map()\n                this.toc = Array.from(doc.querySelectorAll('a[filepos]'))\n                    .reduce((arr, a) => {\n                        const indent = getIndent(a)\n                        const item = {\n                            label: a.innerText?.trim() ?? '',\n                            href: `filepos:${a.getAttribute('filepos')}`,\n                        }\n                        const level = indent > lastIndent ? lastLevel + 1\n                            : indent === lastIndent ? lastLevel\n                            : lastLevelOfIndent.get(indent) ?? Math.max(0, lastLevel - 1)\n                        if (level > lastLevel) {\n                            if (lastItem) {\n                                lastItem.subitems ??= []\n                                lastItem.subitems.push(item)\n                                lastParentOfLevel.set(level, lastItem)\n                            }\n                            else arr.push(item)\n                        }\n                        else {\n                            const parent = lastParentOfLevel.get(level)\n                            if (parent) parent.subitems.push(item)\n                            else arr.push(item)\n                        }\n                        lastItem = item\n                        lastLevel = level\n                        lastIndent = indent\n                        lastLevelOfIndent.set(indent, level)\n                        return arr\n                    }, [])\n            }\n        } catch(e) {\n            console.warn(e)\n        }\n\n        // get list of all `filepos` references in the book,\n        // which will be used to insert anchor elements\n        // because only then can they be referenced in the DOM\n        this.#fileposList = [...new Set(\n            Array.from(str.matchAll(fileposRegex), m => m[1]))]\n            .map(filepos => ({ filepos, number: Number(filepos) }))\n            .sort((a, b) => a.number - b.number)\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    async getGuide() {\n        const doc = await this.createDocument(this.#sections[0])\n        return Array.from(doc.getElementsByTagName('reference'), ref => ({\n            label: ref.getAttribute('title'),\n            type: ref.getAttribute('type')?.split(/\\s/),\n            href: `filepos:${ref.getAttribute('filepos')}`,\n        }))\n    }\n    async loadResource(index) {\n        if (this.#resourceCache.has(index)) return this.#resourceCache.get(index)\n        const raw = await this.mobi.loadResource(index)\n        const url = URL.createObjectURL(new Blob([raw]))\n        this.#resourceCache.set(index, url)\n        return url\n    }\n    async loadRecindex(recindex) {\n        return this.loadResource(Number(recindex) - 1)\n    }\n    async replaceResources(doc) {\n        for (const img of doc.querySelectorAll('img[recindex]')) {\n            const recindex = img.getAttribute('recindex')\n            try {\n                img.src = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load image ${recindex}`)\n            }\n        }\n        for (const media of doc.querySelectorAll('[mediarecindex]')) {\n            const mediarecindex = media.getAttribute('mediarecindex')\n            const recindex = media.getAttribute('recindex')\n            try {\n                media.src = await this.loadRecindex(mediarecindex)\n                if (recindex) media.poster = await this.loadRecindex(recindex)\n            } catch {\n                console.warn(`Failed to load media ${mediarecindex}`)\n            }\n        }\n        for (const a of doc.querySelectorAll('[filepos]')) {\n            const filepos = a.getAttribute('filepos')\n            a.href = `filepos:${filepos}`\n        }\n    }\n    async loadText(section) {\n        if (this.#textCache.has(section)) return this.#textCache.get(section)\n        const { raw } = section\n\n        // insert anchor elements for each `filepos`\n        const fileposList = this.#fileposList\n            .filter(({ number }) => number >= section.start && number < section.end)\n            .map(obj => ({ ...obj, offset: obj.number - section.start }))\n        let arr = raw\n        if (fileposList.length) {\n            arr = raw.subarray(0, fileposList[0].offset)\n            fileposList.forEach(({ filepos, offset }, i) => {\n                const next = fileposList[i + 1]\n                const a = this.mobi.encode(`<a id=\"filepos${filepos}\"></a>`)\n                arr = concatTypedArray3(arr, a, raw.subarray(offset, next?.offset))\n            })\n        }\n        const str = this.mobi.decode(arr).replaceAll(mbpPagebreakRegex, '')\n        this.#textCache.set(section, str)\n        return str\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const doc = await this.createDocument(section)\n\n        // inject default stylesheet\n        const style = doc.createElement('style')\n        doc.head.append(style)\n        // blockquotes in MOBI seem to have only a small left margin by default\n        // many books seem to rely on this, as it's the only way to set margin\n        // (since there's no CSS)\n        style.append(doc.createTextNode(`blockquote {\n            margin-block-start: 0;\n            margin-block-end: 0;\n            margin-inline-start: 1em;\n            margin-inline-end: 0;\n        }`))\n\n        await this.replaceResources(doc)\n        const result = this.serializer.serializeToString(doc)\n        const url = URL.createObjectURL(new Blob([result], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    resolveHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        const anchor = doc => doc.getElementById(`filepos${filepos}`)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const filepos = href.match(/filepos:(.*)/)[1]\n        const number = Number(filepos)\n        const index = this.#sections.findIndex(section => section.end > number)\n        return [index, `filepos${filepos}`]\n    }\n    getTOCFragment(doc, id) {\n        return doc.getElementById(id)\n    }\n    isExternal(uri) {\n        return /^(?!blob|filepos)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#resourceCache.values()) URL.revokeObjectURL(url)\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n\n// handlers for `kindle:` uris\nconst kindleResourceRegex = /kindle:(flow|embed):(\\w+)(?:\\?mime=(\\w+\\/[-+.\\w]+))?/\nconst kindlePosRegex = /kindle:pos:fid:(\\w+):off:(\\w+)/\nconst parseResourceURI = str => {\n    const [resourceType, id, type] = str.match(kindleResourceRegex).slice(1)\n    return { resourceType, id: parseInt(id, 32), type }\n}\nconst parsePosURI = str => {\n    const [fid, off] = str.match(kindlePosRegex).slice(1)\n    return { fid: parseInt(fid, 32), off: parseInt(off, 32) }\n}\nconst makePosURI = (fid = 0, off = 0) =>\n    `kindle:pos:fid:${fid.toString(32).toUpperCase().padStart(4, '0')\n    }:off:${off.toString(32).toUpperCase().padStart(10, '0')}`\n\n// `kindle:pos:` links are originally links that contain fragments identifiers\n// so there should exist an element with `id` or `name`\n// otherwise try to find one with an `aid` attribute\nconst getFragmentSelector = str => {\n    const match = str.match(/\\s(id|name|aid)\\s*=\\s*['\"]([^'\"]*)['\"]/i)\n    if (!match) return\n    const [, attr, value] = match\n    return `[${attr}=\"${CSS.escape(value)}\"]`\n}\n\n// replace asynchronously and sequentially\nconst replaceSeries = async (str, regex, f) => {\n    const matches = []\n    str.replace(regex, (...args) => (matches.push(args), null))\n    const results = []\n    for (const args of matches) results.push(await f(...args))\n    return str.replace(regex, () => results.shift())\n}\n\nconst getPageSpread = properties => {\n    for (const p of properties) {\n        if (p === 'page-spread-left' || p === 'rendition:page-spread-left')\n            return 'left'\n        if (p === 'page-spread-right' || p === 'rendition:page-spread-right')\n            return 'right'\n        if (p === 'rendition:page-spread-center') return 'center'\n    }\n}\n\nclass KF8 {\n    parser = new DOMParser()\n    serializer = new XMLSerializer()\n    transformTarget = new EventTarget()\n    #cache = new Map()\n    #fragmentOffsets = new Map()\n    #fragmentSelectors = new Map()\n    #tables = {}\n    #sections\n    #fullRawLength\n    #rawHead = new Uint8Array()\n    #rawTail = new Uint8Array()\n    #lastLoadedHead = -1\n    #lastLoadedTail = -1\n    #type = MIME.XHTML\n    #inlineMap = new Map()\n    constructor(mobi) {\n        this.mobi = mobi\n    }\n    async init() {\n        const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n        const { kf8 } = this.mobi.headers\n\n        try {\n            const fdstBuffer = await loadRecord(kf8.fdst)\n            const fdst = getStruct(FDST_HEADER, fdstBuffer)\n            if (fdst.magic !== 'FDST') throw new Error('Missing FDST record')\n            const fdstTable = Array.from({ length: fdst.numEntries },\n                (_, i) => 12 + i * 8)\n                .map(offset => [\n                    getUint(fdstBuffer.slice(offset, offset + 4)),\n                    getUint(fdstBuffer.slice(offset + 4, offset + 8))])\n            this.#tables.fdstTable = fdstTable\n            this.#fullRawLength = fdstTable[fdstTable.length - 1][1]\n        } catch {}\n\n        const skelTable = (await getIndexData(kf8.skel, loadRecord)).table\n            .map(({ name, tagMap }, index) => ({\n                index, name,\n                numFrag: tagMap[1][0],\n                offset: tagMap[6][0],\n                length: tagMap[6][1],\n            }))\n        const fragData = await getIndexData(kf8.frag, loadRecord)\n        const fragTable = fragData.table.map(({ name, tagMap }) => ({\n            insertOffset: parseInt(name),\n            selector: fragData.cncx[tagMap[2][0]],\n            index: tagMap[4][0],\n            offset: tagMap[6][0],\n            length: tagMap[6][1],\n        }))\n        this.#tables.skelTable = skelTable\n        this.#tables.fragTable = fragTable\n\n        this.#sections = skelTable.reduce((arr, skel) => {\n            const last = arr[arr.length - 1]\n            const fragStart = last?.fragEnd ?? 0, fragEnd = fragStart + skel.numFrag\n            const frags = fragTable.slice(fragStart, fragEnd)\n            const length = skel.length + frags.map(f => f.length).reduce((a, b) => a + b)\n            const totalLength = (last?.totalLength ?? 0) + length\n            return arr.concat({ skel, frags, fragEnd, length, totalLength })\n        }, [])\n\n        const resources = await this.getResourcesByMagic(['RESC', 'PAGE'])\n        const pageSpreads = new Map()\n        if (resources.RESC) {\n            const buf = await this.mobi.loadRecord(resources.RESC)\n            const str = this.mobi.decode(buf.slice(16)).replace(/\\0/g, '')\n            // the RESC record lacks the root `<package>` element\n            // but seem to be otherwise valid XML\n            const index = str.search(/\\?>/)\n            const xmlStr = `<package>${str.slice(index)}</package>`\n            const opf = this.parser.parseFromString(xmlStr, MIME.XML)\n            for (const $itemref of opf.querySelectorAll('spine > itemref')) {\n                const i = parseInt($itemref.getAttribute('skelid'))\n                pageSpreads.set(i, getPageSpread(\n                    $itemref.getAttribute('properties')?.split(' ') ?? []))\n            }\n        }\n\n        this.sections = this.#sections.map((section, index) =>\n            section.frags.length ? ({\n                id: index,\n                load: () => this.loadSection(section),\n                createDocument: () => this.createDocument(section),\n                size: section.length,\n                pageSpread: pageSpreads.get(index),\n            }) : ({ linear: 'no' }))\n\n        try {\n            const ncx = await this.mobi.getNCX()\n            const map = ({ label, pos, children }) => {\n                const [fid, off] = pos\n                const href = makePosURI(fid, off)\n                const arr = this.#fragmentOffsets.get(fid)\n                if (arr) arr.push(off)\n                else this.#fragmentOffsets.set(fid, [off])\n                return { label: unescapeHTML(label), href, subitems: children?.map(map) }\n            }\n            this.toc = ncx?.map(map)\n            this.landmarks = await this.getGuide()\n        } catch(e) {\n            console.warn(e)\n        }\n\n        const { exth } = this.mobi.headers\n        this.dir = exth.pageProgressionDirection\n        this.rendition = {\n            layout: exth.fixedLayout === 'true' ? 'pre-paginated' : 'reflowable',\n            viewport: Object.fromEntries(exth.originalResolution\n                ?.split('x')?.slice(0, 2)\n                ?.map((x, i) => [i ? 'height' : 'width', x]) ?? []),\n        }\n\n        this.metadata = this.mobi.getMetadata()\n        this.getCover = this.mobi.getCover.bind(this.mobi)\n        return this\n    }\n    // is this really the only way of getting to RESC, PAGE, etc.?\n    async getResourcesByMagic(keys) {\n        const results = {}\n        const start = this.mobi.headers.kf8.resourceStart\n        const end = this.mobi.pdb.numRecords\n        for (let i = start; i < end; i++) {\n            try {\n                const magic = await this.mobi.loadMagic(i)\n                const match = keys.find(key => key === magic)\n                if (match) results[match] = i\n            } catch {}\n        }\n        return results\n    }\n    async getGuide() {\n        const index = this.mobi.headers.kf8.guide\n        if (index < 0xffffffff) {\n            const loadRecord = this.mobi.loadRecord.bind(this.mobi)\n            const { table, cncx } = await getIndexData(index, loadRecord)\n            return table.map(({ name, tagMap }) => ({\n                label: cncx[tagMap[1][0]] ?? '',\n                type: name?.split(/\\s/),\n                href: makePosURI(tagMap[6]?.[0] ?? tagMap[3]?.[0]),\n            }))\n        }\n    }\n    async loadResourceBlob(str) {\n        const { resourceType, id, type } = parseResourceURI(str)\n        const raw = resourceType === 'flow' ? await this.loadFlow(id)\n            : await this.mobi.loadResource(id - 1)\n        const result = [MIME.XHTML, MIME.HTML, MIME.CSS, MIME.SVG].includes(type)\n            ? await this.replaceResources(this.mobi.decode(raw)) : raw\n        const detail = { data: result, type }\n        const event = new CustomEvent('data', { detail })\n        this.transformTarget.dispatchEvent(event)\n        const newData = await event.detail.data\n        const newType = await event.detail.type\n        const doc = newType === MIME.SVG ? this.parser.parseFromString(newData, newType) : null\n        return [new Blob([newData], { newType }),\n            // SVG wrappers need to be inlined\n            // as browsers don't allow external resources when loading SVG as an image\n            doc?.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'image')?.length\n                ? doc.documentElement : null]\n    }\n    async loadResource(str) {\n        if (this.#cache.has(str)) return this.#cache.get(str)\n        const [blob, inline] = await this.loadResourceBlob(str)\n        const url = inline ? str : URL.createObjectURL(blob)\n        if (inline) this.#inlineMap.set(url, inline)\n        this.#cache.set(str, url)\n        return url\n    }\n    replaceResources(str) {\n        const regex = new RegExp(kindleResourceRegex, 'g')\n        return replaceSeries(str, regex, this.loadResource.bind(this))\n    }\n    // NOTE: there doesn't seem to be a way to access text randomly?\n    // how to know the decompressed size of the records without decompressing?\n    // 4096 is just the maximum size\n    async loadRaw(start, end) {\n        // here we load either from the front or back until we have reached the\n        // required offsets; at worst you'd have to load half the book at once\n        const distanceHead = end - this.#rawHead.length\n        const distanceEnd = this.#fullRawLength == null ? Infinity\n            : (this.#fullRawLength - this.#rawTail.length) - start\n        // load from the start\n        if (distanceHead < 0 || distanceHead < distanceEnd) {\n            while (this.#rawHead.length < end) {\n                const index = ++this.#lastLoadedHead\n                const data = await this.mobi.loadText(index)\n                this.#rawHead = concatTypedArray(this.#rawHead, data)\n            }\n            return this.#rawHead.slice(start, end)\n        }\n        // load from the end\n        while (this.#fullRawLength - this.#rawTail.length > start) {\n            const index = this.mobi.headers.palmdoc.numTextRecords - 1\n                - (++this.#lastLoadedTail)\n            const data = await this.mobi.loadText(index)\n            this.#rawTail = concatTypedArray(data, this.#rawTail)\n        }\n        const rawTailStart = this.#fullRawLength - this.#rawTail.length\n        return this.#rawTail.slice(start - rawTailStart, end - rawTailStart)\n    }\n    loadFlow(index) {\n        if (index < 0xffffffff)\n            return this.loadRaw(...this.#tables.fdstTable[index])\n    }\n    async loadText(section) {\n        const { skel, frags, length } = section\n        const raw = await this.loadRaw(skel.offset, skel.offset + length)\n        let skeleton = raw.slice(0, skel.length)\n        for (const frag of frags) {\n            const insertOffset = frag.insertOffset - skel.offset\n            const offset = skel.length + frag.offset\n            const fragRaw = raw.slice(offset, offset + frag.length)\n            skeleton = concatTypedArray3(\n                skeleton.slice(0, insertOffset), fragRaw,\n                skeleton.slice(insertOffset))\n\n            const offsets = this.#fragmentOffsets.get(frag.index)\n            if (offsets) for (const offset of offsets) {\n                const str = this.mobi.decode(fragRaw).slice(offset)\n                const selector = getFragmentSelector(str)\n                this.#setFragmentSelector(frag.index, offset, selector)\n            }\n        }\n        return this.mobi.decode(skeleton)\n    }\n    async createDocument(section) {\n        const str = await this.loadText(section)\n        return this.parser.parseFromString(str, this.#type)\n    }\n    async loadSection(section) {\n        if (this.#cache.has(section)) return this.#cache.get(section)\n        const str = await this.loadText(section)\n        const replaced = await this.replaceResources(str)\n\n        // by default, type is XHTML; change to HTML if it's not valid XHTML\n        let doc = this.parser.parseFromString(replaced, this.#type)\n        if (doc.querySelector('parsererror') || !doc.documentElement?.namespaceURI) {\n            this.#type = MIME.HTML\n            doc = this.parser.parseFromString(replaced, this.#type)\n        }\n        for (const [url, node] of this.#inlineMap) {\n            for (const el of doc.querySelectorAll(`img[src=\"${url}\"]`))\n                el.replaceWith(node)\n        }\n        const url = URL.createObjectURL(\n            new Blob([this.serializer.serializeToString(doc)], { type: this.#type }))\n        this.#cache.set(section, url)\n        return url\n    }\n    getIndexByFID(fid) {\n        return this.#sections.findIndex(section =>\n            section.frags.some(frag => frag.index === fid))\n    }\n    #setFragmentSelector(id, offset, selector) {\n        const map = this.#fragmentSelectors.get(id)\n        if (map) map.set(offset, selector)\n        else {\n            const map = new Map()\n            this.#fragmentSelectors.set(id, map)\n            map.set(offset, selector)\n        }\n    }\n    async resolveHref(href) {\n        const { fid, off } = parsePosURI(href)\n        const index = this.getIndexByFID(fid)\n        if (index < 0) return\n\n        const saved = this.#fragmentSelectors.get(fid)?.get(off)\n        if (saved) return { index, anchor: doc => doc.querySelector(saved) }\n\n        const { skel, frags } = this.#sections[index]\n        const frag = frags.find(frag => frag.index === fid)\n        const offset = skel.offset + skel.length + frag.offset\n        const fragRaw = await this.loadRaw(offset, offset + frag.length)\n        const str = this.mobi.decode(fragRaw).slice(off)\n        const selector = getFragmentSelector(str)\n        this.#setFragmentSelector(fid, off, selector)\n        const anchor = doc => doc.querySelector(selector)\n        return { index, anchor }\n    }\n    splitTOCHref(href) {\n        const pos = parsePosURI(href)\n        const index = this.getIndexByFID(pos.fid)\n        return [index, pos]\n    }\n    getTOCFragment(doc, { fid, off }) {\n        const selector = this.#fragmentSelectors.get(fid)?.get(off)\n        return doc.querySelector(selector)\n    }\n    isExternal(uri) {\n        return /^(?!blob|kindle)\\w+:/i.test(uri)\n    }\n    destroy() {\n        for (const url of this.#cache.values()) URL.revokeObjectURL(url)\n    }\n}\n"],"names":["unescapeHTML","str","textarea","MIME","PDB_HEADER","PALMDOC_HEADER","MOBI_HEADER","KF8_HEADER","EXTH_HEADER","INDX_HEADER","TAGX_HEADER","HUFF_HEADER","CDIC_HEADER","FDST_HEADER","FONT_HEADER","MOBI_ENCODING","EXTH_RECORD_TYPE","MOBI_LANG","concatTypedArray","a","b","result","concatTypedArray3","c","decoder","getString","buffer","getUint","l","func","getStruct","def","key","start","len","type","getDecoder","x","getVarLen","byteArray","i","value","length","byte","getVarLenFromEnd","countBitsSet","count","countUnsetEnd","decompressPalmDOC","array","output","bytes","distance","j","read32Bits","from","startByte","end","endByte","bits","huffcdic","mobi","loadRecord","huffRecord","magic","offset1","offset2","table1","_","offset","table2","dictionary","record","cdic","n","decompressed","decompress","bitLength","found","codeLength","code","getIndexData","indxIndex","indxRecord","indx","tagxBuffer","tagx","numTags","tagTable","cncx","cncxRecordOffset","pos","index","table","offsetOffset","name","tags","startPos","controlByteIndex","tag","numValues","mask","tagMap","valueCount","valueBytes","values","getNCX","items","getChildren","item","getEXTH","buf","encoding","results","typ","many","data","getFont","unzlib","flags","dataStart","keyLength","keyStart","e","isMOBI","file","PDB","#file","#offsets","pdb","offsets","MOBI","#start","#resourceStart","#decoder","#encoder","#decompress","#removeTrailingEntries","#getHeaders","isKF8","boundary","#setup","KF8","MOBI6","palmdoc","titleOffset","titleLength","localeLanguage","localeRegion","lang","exth","kf8","compression","f","trailingFlags","multibyte","numTrailingEntries","args","mbpPagebreakRegex","fileposRegex","getIndent","el","parent","#resourceCache","#textCache","#cache","#sections","#fileposList","#type","m","raw","arr","last","section","tocHref","doc","lastItem","lastLevel","lastIndent","lastLevelOfIndent","lastParentOfLevel","indent","level","filepos","ref","url","recindex","img","media","mediarecindex","fileposList","number","obj","next","style","href","id","uri","kindleResourceRegex","kindlePosRegex","parseResourceURI","resourceType","parsePosURI","fid","off","makePosURI","getFragmentSelector","match","attr","replaceSeries","regex","matches","getPageSpread","properties","p","#fragmentOffsets","#fragmentSelectors","#tables","#fullRawLength","#rawHead","#rawTail","#lastLoadedHead","#lastLoadedTail","#inlineMap","fdstBuffer","fdst","fdstTable","skelTable","fragData","fragTable","skel","fragStart","fragEnd","frags","totalLength","resources","pageSpreads","xmlStr","opf","$itemref","ncx","map","label","children","keys","detail","event","newData","newType","blob","inline","distanceHead","distanceEnd","rawTailStart","skeleton","frag","insertOffset","fragRaw","selector","#setFragmentSelector","replaced","node","saved"],"mappings":"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","x_google_ignoreList":[0]}