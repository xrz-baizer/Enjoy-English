{"version":3,"file":"search-UHG1SVDO.js","sources":["../../../../node_modules/foliate-js/search.js"],"sourcesContent":["// length for context in excerpts\nconst CONTEXT_LENGTH = 50\n\nconst normalizeWhitespace = str => str.replace(/\\s+/g, ' ')\n\nconst makeExcerpt = (strs, { startIndex, startOffset, endIndex, endOffset }) => {\n    const start = strs[startIndex]\n    const end = strs[endIndex]\n    const match = start === end\n        ? start.slice(startOffset, endOffset)\n        : start.slice(startOffset)\n            + strs.slice(start + 1, end).join('')\n            + end.slice(0, endOffset)\n    const trimmedStart = normalizeWhitespace(start.slice(0, startOffset)).trimStart()\n    const trimmedEnd = normalizeWhitespace(end.slice(endOffset)).trimEnd()\n    const ellipsisPre = trimmedStart.length < CONTEXT_LENGTH ? '' : '…'\n    const ellipsisPost = trimmedEnd.length < CONTEXT_LENGTH ? '' : '…'\n    const pre = `${ellipsisPre}${trimmedStart.slice(-CONTEXT_LENGTH)}`\n    const post = `${trimmedEnd.slice(0, CONTEXT_LENGTH)}${ellipsisPost}`\n    return { pre, match, post }\n}\n\nconst simpleSearch = function* (strs, query, options = {}) {\n    const { locales = 'en', sensitivity } = options\n    const matchCase = sensitivity === 'variant'\n    const haystack = strs.join('')\n    const lowerHaystack = matchCase ? haystack : haystack.toLocaleLowerCase(locales)\n    const needle = matchCase ? query : query.toLocaleLowerCase(locales)\n    const needleLength = needle.length\n    let index = -1\n    let strIndex = -1\n    let sum = 0\n    do {\n        index = lowerHaystack.indexOf(needle, index + 1)\n        if (index > -1) {\n            while (sum <= index) sum += strs[++strIndex].length\n            const startIndex = strIndex\n            const startOffset = index - (sum - strs[strIndex].length)\n            const end = index + needleLength\n            while (sum <= end) sum += strs[++strIndex].length\n            const endIndex = strIndex\n            const endOffset = end - (sum - strs[strIndex].length)\n            const range = { startIndex, startOffset, endIndex, endOffset }\n            yield { range, excerpt: makeExcerpt(strs, range) }\n        }\n    } while (index > -1)\n}\n\nconst segmenterSearch = function* (strs, query, options = {}) {\n    const { locales = 'en', granularity = 'word', sensitivity = 'base' } = options\n    let segmenter, collator\n    try {\n        segmenter = new Intl.Segmenter(locales, { usage: 'search', granularity })\n        collator = new Intl.Collator(locales, { sensitivity })\n    } catch (e) {\n        console.warn(e)\n        segmenter = new Intl.Segmenter('en', { usage: 'search', granularity })\n        collator = new Intl.Collator('en', { sensitivity })\n    }\n    const queryLength = Array.from(segmenter.segment(query)).length\n\n    const substrArr = []\n    let strIndex = 0\n    let segments = segmenter.segment(strs[strIndex])[Symbol.iterator]()\n    main: while (strIndex < strs.length) {\n        while (substrArr.length < queryLength) {\n            const { done, value } = segments.next()\n            if (done) {\n                // the current string is exhausted\n                // move on to the next string\n                strIndex++\n                if (strIndex < strs.length) {\n                    segments = segmenter.segment(strs[strIndex])[Symbol.iterator]()\n                    continue\n                } else break main\n            }\n            const { index, segment } = value\n            // ignore formatting characters\n            if (!/[^\\p{Format}]/u.test(segment)) continue\n            // normalize whitespace\n            if (/\\s/u.test(segment)) {\n                if (!/\\s/u.test(substrArr[substrArr.length - 1]?.segment))\n                    substrArr.push({ strIndex, index, segment: ' ' })\n                continue\n            }\n            value.strIndex = strIndex\n            substrArr.push(value)\n        }\n        const substr = substrArr.map(x => x.segment).join('')\n        if (collator.compare(query, substr) === 0) {\n            const endIndex = strIndex\n            const lastSeg = substrArr[substrArr.length - 1]\n            const endOffset = lastSeg.index + lastSeg.segment.length\n            const startIndex = substrArr[0].strIndex\n            const startOffset = substrArr[0].index\n            const range = { startIndex, startOffset, endIndex, endOffset }\n            yield { range, excerpt: makeExcerpt(strs, range) }\n        }\n        substrArr.shift()\n    }\n}\n\nexport const search = (strs, query, options) => {\n    const { granularity = 'grapheme', sensitivity = 'base' } = options\n    if (!Intl?.Segmenter || granularity === 'grapheme'\n    && (sensitivity === 'variant' || sensitivity === 'accent'))\n        return simpleSearch(strs, query, options)\n    return segmenterSearch(strs, query, options)\n}\n\nexport const searchMatcher = (textWalker, opts) => {\n    const { defaultLocale, matchCase, matchDiacritics, matchWholeWords, acceptNode } = opts\n    return function* (doc, query) {\n        const iter = textWalker(doc, function* (strs, makeRange) {\n            for (const result of search(strs, query, {\n                locales: doc.body.lang || doc.documentElement.lang || defaultLocale || 'en',\n                granularity: matchWholeWords ? 'word' : 'grapheme',\n                sensitivity: matchDiacritics && matchCase ? 'variant'\n                : matchDiacritics && !matchCase ? 'accent'\n                : !matchDiacritics && matchCase ? 'case'\n                : 'base',\n            })) {\n                const { startIndex, startOffset, endIndex, endOffset } = result.range\n                result.range = makeRange(startIndex, startOffset, endIndex, endOffset)\n                yield result\n            }\n        }, acceptNode)\n        for (const result of iter) yield result\n    }\n}\n"],"names":["normalizeWhitespace","str","makeExcerpt","strs","startIndex","startOffset","endIndex","endOffset","start","end","match","trimmedStart","trimmedEnd","ellipsisPre","ellipsisPost","pre","post","simpleSearch","query","options","locales","sensitivity","matchCase","haystack","lowerHaystack","needle","needleLength","index","strIndex","sum","range","segmenterSearch","granularity","segmenter","collator","e","queryLength","substrArr","segments","main","done","value","segment","substr","x","lastSeg","search","searchMatcher","textWalker","opts","defaultLocale","matchDiacritics","matchWholeWords","acceptNode","doc","iter","makeRange","result"],"mappings":"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","x_google_ignoreList":[0]}