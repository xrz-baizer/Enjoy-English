{"version":3,"file":"tts-ColYPQ7G.js","sources":["../../../../node_modules/foliate-js/tts.js"],"sourcesContent":["const NS = {\n    XML: 'http://www.w3.org/XML/1998/namespace',\n    SSML: 'http://www.w3.org/2001/10/synthesis',\n}\n\nconst blockTags = new Set([\n    'article', 'aside', 'audio', 'blockquote', 'caption',\n    'details', 'dialog', 'div', 'dl', 'dt', 'dd',\n    'figure', 'footer', 'form', 'figcaption',\n    'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'li',\n    'main', 'math', 'nav', 'ol', 'p', 'pre', 'section', 'tr',\n])\n\nconst getLang = el => {\n    const x = el.lang || el?.getAttributeNS?.(NS.XML, 'lang')\n    return x ? x : el.parentElement ? getLang(el.parentElement) : null\n}\n\nconst getAlphabet = el => {\n    const x = el?.getAttributeNS?.(NS.XML, 'lang')\n    return x ? x : el.parentElement ? getAlphabet(el.parentElement) : null\n}\n\nconst getSegmenter = (lang = 'en', granularity = 'word') => {\n    const segmenter = new Intl.Segmenter(lang, { granularity })\n    const granularityIsWord = granularity === 'word'\n    return function* (strs, makeRange) {\n        const str = strs.join('')\n        let name = 0\n        let strIndex = -1\n        let sum = 0\n        for (const { index, segment, isWordLike } of segmenter.segment(str)) {\n            if (granularityIsWord && !isWordLike) continue\n            while (sum <= index) sum += strs[++strIndex].length\n            const startIndex = strIndex\n            const startOffset = index - (sum - strs[strIndex].length)\n            const end = index + segment.length - 1\n            if (end < str.length) while (sum <= end) sum += strs[++strIndex].length\n            const endIndex = strIndex\n            const endOffset = end - (sum - strs[strIndex].length) + 1\n            yield [(name++).toString(),\n                makeRange(startIndex, startOffset, endIndex, endOffset)]\n        }\n    }\n}\n\nconst fragmentToSSML = (fragment, inherited) => {\n    const ssml = document.implementation.createDocument(NS.SSML, 'speak')\n    const { lang } = inherited\n    if (lang) ssml.documentElement.setAttributeNS(NS.XML, 'lang', lang)\n\n    const convert = (node, parent, inheritedAlphabet) => {\n        if (!node) return\n        if (node.nodeType === 3) return ssml.createTextNode(node.textContent)\n        if (node.nodeType === 4) return ssml.createCDATASection(node.textContent)\n        if (node.nodeType !== 1) return\n\n        let el\n        const nodeName = node.nodeName.toLowerCase()\n        if (nodeName === 'foliate-mark') {\n            el = ssml.createElementNS(NS.SSML, 'mark')\n            el.setAttribute('name', node.dataset.name)\n        }\n        else if (nodeName === 'br')\n            el = ssml.createElementNS(NS.SSML, 'break')\n        else if (nodeName === 'em' || nodeName === 'strong')\n            el = ssml.createElementNS(NS.SSML, 'emphasis')\n\n        const lang = node.lang || node.getAttributeNS(NS.XML, 'lang')\n        if (lang) {\n            if (!el) el = ssml.createElementNS(NS.SSML, 'lang')\n            el.setAttributeNS(NS.XML, 'lang', lang)\n        }\n\n        const alphabet = node.getAttributeNS(NS.SSML, 'alphabet') || inheritedAlphabet\n        if (!el) {\n            const ph = node.getAttributeNS(NS.SSML, 'ph')\n            if (ph) {\n                el = ssml.createElementNS(NS.SSML, 'phoneme')\n                if (alphabet) el.setAttribute('alphabet', alphabet)\n                el.setAttribute('ph', ph)\n            }\n        }\n\n        if (!el) el = parent\n\n        let child = node.firstChild\n        while (child) {\n            const childEl = convert(child, el, alphabet)\n            if (childEl && el !== childEl) el.append(childEl)\n            child = child.nextSibling\n        }\n        return el\n    }\n    convert(fragment.firstChild, ssml.documentElement, inherited.alphabet)\n    return ssml\n}\n\nconst getFragmentWithMarks = (range, textWalker, granularity) => {\n    const lang = getLang(range.commonAncestorContainer)\n    const alphabet = getAlphabet(range.commonAncestorContainer)\n\n    const segmenter = getSegmenter(lang, granularity)\n    const fragment = range.cloneContents()\n\n    // we need ranges on both the original document (for highlighting)\n    // and the document fragment (for inserting marks)\n    // so unfortunately need to do it twice, as you can't copy the ranges\n    const entries = [...textWalker(range, segmenter)]\n    const fragmentEntries = [...textWalker(fragment, segmenter)]\n\n    for (const [name, range] of fragmentEntries) {\n        const mark = document.createElement('foliate-mark')\n        mark.dataset.name = name\n        range.insertNode(mark)\n    }\n    const ssml = fragmentToSSML(fragment, { lang, alphabet })\n    return { entries, ssml }\n}\n\nconst rangeIsEmpty = range => !range.toString().trim()\n\nfunction* getBlocks(doc) {\n    let last\n    const walker = doc.createTreeWalker(doc.body, NodeFilter.SHOW_ELEMENT)\n    for (let node = walker.nextNode(); node; node = walker.nextNode()) {\n        const name = node.tagName.toLowerCase()\n        if (blockTags.has(name)) {\n            if (last) {\n                last.setEndBefore(node)\n                if (!rangeIsEmpty(last)) yield last\n            }\n            last = doc.createRange()\n            last.setStart(node, 0)\n        }\n    }\n    if (!last) {\n        last = doc.createRange()\n        last.setStart(doc.body.firstChild ?? doc.body, 0)\n    }\n    last.setEndAfter(doc.body.lastChild ?? doc.body)\n    if (!rangeIsEmpty(last)) yield last\n}\n\nclass ListIterator {\n    #arr = []\n    #iter\n    #index = -1\n    #f\n    constructor(iter, f = x => x) {\n        this.#iter = iter\n        this.#f = f\n    }\n    current() {\n        if (this.#arr[this.#index]) return this.#f(this.#arr[this.#index])\n    }\n    first() {\n        const newIndex = 0\n        if (this.#arr[newIndex]) {\n            this.#index = newIndex\n            return this.#f(this.#arr[newIndex])\n        }\n    }\n    prev() {\n        const newIndex = this.#index - 1\n        if (this.#arr[newIndex]) {\n            this.#index = newIndex\n            return this.#f(this.#arr[newIndex])\n        }\n    }\n    next() {\n        const newIndex = this.#index + 1\n        if (this.#arr[newIndex]) {\n            this.#index = newIndex\n            return this.#f(this.#arr[newIndex])\n        }\n        while (true) {\n            const { done, value } = this.#iter.next()\n            if (done) break\n            this.#arr.push(value)\n            if (this.#arr[newIndex]) {\n                this.#index = newIndex\n                return this.#f(this.#arr[newIndex])\n            }\n        }\n    }\n    find(f) {\n        const index = this.#arr.findIndex(x => f(x))\n        if (index > -1) {\n            this.#index = index\n            return this.#f(this.#arr[index])\n        }\n        while (true) {\n            const { done, value } = this.#iter.next()\n            if (done) break\n            this.#arr.push(value)\n            if (f(value)) {\n                this.#index = this.#arr.length - 1\n                return this.#f(value)\n            }\n        }\n    }\n}\n\nexport class TTS {\n    #list\n    #ranges\n    #lastMark\n    #serializer = new XMLSerializer()\n    constructor(doc, textWalker, highlight, granularity) {\n        this.doc = doc\n        this.highlight = highlight\n        this.#list = new ListIterator(getBlocks(doc), range => {\n            const { entries, ssml } = getFragmentWithMarks(range, textWalker, granularity)\n            this.#ranges = new Map(entries)\n            return [ssml, range]\n        })\n    }\n    #getMarkElement(doc, mark) {\n        if (!mark) return null\n        return doc.querySelector(`mark[name=\"${CSS.escape(mark)}\"`)\n    }\n    #speak(doc, getNode) {\n        if (!doc) return\n        if (!getNode) return this.#serializer.serializeToString(doc)\n        const ssml = document.implementation.createDocument(NS.SSML, 'speak')\n        ssml.documentElement.replaceWith(ssml.importNode(doc.documentElement, true))\n        let node = getNode(ssml)?.previousSibling\n        while (node) {\n            const next = node.previousSibling ?? node.parentNode?.previousSibling\n            node.parentNode.removeChild(node)\n            node = next\n        }\n        return this.#serializer.serializeToString(ssml)\n    }\n    start() {\n        this.#lastMark = null\n        const [doc] = this.#list.first() ?? []\n        if (!doc) return this.next()\n        return this.#speak(doc, ssml => this.#getMarkElement(ssml, this.#lastMark))\n    }\n    resume() {\n        const [doc] = this.#list.current() ?? []\n        if (!doc) return this.next()\n        return this.#speak(doc, ssml => this.#getMarkElement(ssml, this.#lastMark))\n    }\n    prev(paused) {\n        this.#lastMark = null\n        const [doc, range] = this.#list.prev() ?? []\n        if (paused && range) this.highlight(range.cloneRange())\n        return this.#speak(doc)\n    }\n    next(paused) {\n        this.#lastMark = null\n        const [doc, range] = this.#list.next() ?? []\n        if (paused && range) this.highlight(range.cloneRange())\n        return this.#speak(doc)\n    }\n    from(range) {\n        this.#lastMark = null\n        const [doc] = this.#list.find(range_ =>\n            range.compareBoundaryPoints(Range.END_TO_START, range_) <= 0)\n        let mark\n        for (const [name, range_] of this.#ranges.entries())\n            if (range.compareBoundaryPoints(Range.START_TO_START, range_) <= 0) {\n                mark = name\n                break\n            }\n        return this.#speak(doc, ssml => this.#getMarkElement(ssml, mark))\n    }\n    setMark(mark) {\n        const range = this.#ranges.get(mark)\n        if (range) {\n            this.#lastMark = mark\n            this.highlight(range.cloneRange())\n        }\n    }\n}\n"],"names":["NS","blockTags","getLang","el","x","getAlphabet","getSegmenter","lang","granularity","segmenter","granularityIsWord","strs","makeRange","str","name","strIndex","sum","index","segment","isWordLike","startIndex","startOffset","end","endIndex","endOffset","fragmentToSSML","fragment","inherited","ssml","convert","node","parent","inheritedAlphabet","nodeName","alphabet","ph","child","childEl","getFragmentWithMarks","range","textWalker","entries","fragmentEntries","mark","rangeIsEmpty","getBlocks","doc","last","walker","ListIterator","#arr","#iter","#index","#f","iter","f","newIndex","done","value","TTS","#list","#ranges","#lastMark","#serializer","highlight","#getMarkElement","#speak","getNode","next","paused","range_"],"mappings":"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","x_google_ignoreList":[0]}