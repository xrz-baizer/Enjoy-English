const Z=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],$t=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],en=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],tn=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],nn=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],rn=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],an=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],be=15;function We(){let n,t,e,r,a,l;function s(f,w,_,g,x,z,c,p,i,o,u){let b,y,k,m,h,A,D,U,v,S,E,O,W,F,C;S=0,h=_;do e[f[w+S]]++,S++,h--;while(h!==0);if(e[0]==_)return c[0]=-1,p[0]=0,0;for(U=p[0],A=1;A<=be&&e[A]===0;A++);for(D=A,U<A&&(U=A),h=be;h!==0&&e[h]===0;h--);for(k=h,U>h&&(U=h),p[0]=U,F=1<<A;A<h;A++,F<<=1)if((F-=e[A])<0)return-3;if((F-=e[h])<0)return-3;for(e[h]+=F,l[1]=A=0,S=1,W=2;--h!=0;)l[W]=A+=e[S],W++,S++;h=0,S=0;do(A=f[w+S])!==0&&(u[l[A]++]=h),S++;while(++h<_);for(_=l[k],l[0]=h=0,S=0,m=-1,O=-U,a[0]=0,E=0,C=0;D<=k;D++)for(b=e[D];b--!=0;){for(;D>O+U;){if(m++,O+=U,C=k-O,C=C>U?U:C,(y=1<<(A=D-O))>b+1&&(y-=b+1,W=D,A<C))for(;++A<C&&!((y<<=1)<=e[++W]);)y-=e[W];if(C=1<<A,o[0]+C>1440)return-3;a[m]=E=o[0],o[0]+=C,m!==0?(l[m]=h,r[0]=A,r[1]=U,A=h>>>O-U,r[2]=E-a[m-1]-A,i.set(r,3*(a[m-1]+A))):c[0]=E}for(r[1]=D-O,S>=_?r[0]=192:u[S]<g?(r[0]=u[S]<256?0:96,r[2]=u[S++]):(r[0]=z[u[S]-g]+16+64,r[2]=x[u[S++]-g]),y=1<<D-O,A=h>>>O;A<C;A+=y)i.set(r,3*(E+A));for(A=1<<D-1;h&A;A>>>=1)h^=A;for(h^=A,v=(1<<O)-1;(h&v)!=l[m];)m--,O-=U,v=(1<<O)-1}return F!==0&&k!=1?-5:0}function d(f){let w;for(n||(n=[],t=[],e=new Int32Array(16),r=[],a=new Int32Array(be),l=new Int32Array(16)),t.length<f&&(t=[]),w=0;w<f;w++)t[w]=0;for(w=0;w<16;w++)e[w]=0;for(w=0;w<3;w++)r[w]=0;a.set(e.subarray(0,be),0),l.set(e.subarray(0,16),0)}this.inflate_trees_bits=function(f,w,_,g,x){let z;return d(19),n[0]=0,z=s(f,0,19,19,null,null,_,w,g,n,t),z==-3?x.msg="oversubscribed dynamic bit lengths tree":z!=-5&&w[0]!==0||(x.msg="incomplete dynamic bit lengths tree",z=-3),z},this.inflate_trees_dynamic=function(f,w,_,g,x,z,c,p,i){let o;return d(288),n[0]=0,o=s(_,0,f,257,tn,nn,z,g,p,n,t),o!=0||g[0]===0?(o==-3?i.msg="oversubscribed literal/length tree":o!=-4&&(i.msg="incomplete literal/length tree",o=-3),o):(d(288),o=s(_,f,w,0,rn,an,c,x,p,n,t),o!=0||x[0]===0&&f>257?(o==-3?i.msg="oversubscribed distance tree":o==-5?(i.msg="incomplete distance tree",o=-3):o!=-4&&(i.msg="empty distance tree with lengths",o=-3),o):0)}}We.inflate_trees_fixed=function(n,t,e,r){return n[0]=9,t[0]=5,e[0]=$t,r[0]=en,0};function sn(){const n=this;let t,e,r,a,l=0,s=0,d=0,f=0,w=0,_=0,g=0,x=0,z=0,c=0;function p(i,o,u,b,y,k,m,h){let A,D,U,v,S,E,O,W,F,C,j,K,T,R,M,L;O=h.next_in_index,W=h.avail_in,S=m.bitb,E=m.bitk,F=m.write,C=F<m.read?m.read-F-1:m.end-F,j=Z[i],K=Z[o];do{for(;E<20;)W--,S|=(255&h.read_byte(O++))<<E,E+=8;if(A=S&j,D=u,U=b,L=3*(U+A),(v=D[L])!==0)for(;;){if(S>>=D[L+1],E-=D[L+1],16&v){for(v&=15,T=D[L+2]+(S&Z[v]),S>>=v,E-=v;E<15;)W--,S|=(255&h.read_byte(O++))<<E,E+=8;for(A=S&K,D=y,U=k,L=3*(U+A),v=D[L];;){if(S>>=D[L+1],E-=D[L+1],16&v){for(v&=15;E<v;)W--,S|=(255&h.read_byte(O++))<<E,E+=8;if(R=D[L+2]+(S&Z[v]),S>>=v,E-=v,C-=T,F>=R)M=F-R,F-M>0&&2>F-M?(m.win[F++]=m.win[M++],m.win[F++]=m.win[M++],T-=2):(m.win.set(m.win.subarray(M,M+2),F),F+=2,M+=2,T-=2);else{M=F-R;do M+=m.end;while(M<0);if(v=m.end-M,T>v){if(T-=v,F-M>0&&v>F-M)do m.win[F++]=m.win[M++];while(--v!=0);else m.win.set(m.win.subarray(M,M+v),F),F+=v,M+=v,v=0;M=0}}if(F-M>0&&T>F-M)do m.win[F++]=m.win[M++];while(--T!=0);else m.win.set(m.win.subarray(M,M+T),F),F+=T,M+=T,T=0;break}if(64&v)return h.msg="invalid distance code",T=h.avail_in-W,T=E>>3<T?E>>3:T,W+=T,O-=T,E-=T<<3,m.bitb=S,m.bitk=E,h.avail_in=W,h.total_in+=O-h.next_in_index,h.next_in_index=O,m.write=F,-3;A+=D[L+2],A+=S&Z[v],L=3*(U+A),v=D[L]}break}if(64&v)return 32&v?(T=h.avail_in-W,T=E>>3<T?E>>3:T,W+=T,O-=T,E-=T<<3,m.bitb=S,m.bitk=E,h.avail_in=W,h.total_in+=O-h.next_in_index,h.next_in_index=O,m.write=F,1):(h.msg="invalid literal/length code",T=h.avail_in-W,T=E>>3<T?E>>3:T,W+=T,O-=T,E-=T<<3,m.bitb=S,m.bitk=E,h.avail_in=W,h.total_in+=O-h.next_in_index,h.next_in_index=O,m.write=F,-3);if(A+=D[L+2],A+=S&Z[v],L=3*(U+A),(v=D[L])===0){S>>=D[L+1],E-=D[L+1],m.win[F++]=D[L+2],C--;break}}else S>>=D[L+1],E-=D[L+1],m.win[F++]=D[L+2],C--}while(C>=258&&W>=10);return T=h.avail_in-W,T=E>>3<T?E>>3:T,W+=T,O-=T,E-=T<<3,m.bitb=S,m.bitk=E,h.avail_in=W,h.total_in+=O-h.next_in_index,h.next_in_index=O,m.write=F,0}n.init=function(i,o,u,b,y,k){t=0,g=i,x=o,r=u,z=b,a=y,c=k,e=null},n.proc=function(i,o,u){let b,y,k,m,h,A,D,U=0,v=0,S=0;for(S=o.next_in_index,m=o.avail_in,U=i.bitb,v=i.bitk,h=i.write,A=h<i.read?i.read-h-1:i.end-h;;)switch(t){case 0:if(A>=258&&m>=10&&(i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,u=p(g,x,r,z,a,c,i,o),S=o.next_in_index,m=o.avail_in,U=i.bitb,v=i.bitk,h=i.write,A=h<i.read?i.read-h-1:i.end-h,u!=0)){t=u==1?7:9;break}d=g,e=r,s=z,t=1;case 1:for(b=d;v<b;){if(m===0)return i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);u=0,m--,U|=(255&o.read_byte(S++))<<v,v+=8}if(y=3*(s+(U&Z[b])),U>>>=e[y+1],v-=e[y+1],k=e[y],k===0){f=e[y+2],t=6;break}if(16&k){w=15&k,l=e[y+2],t=2;break}if(!(64&k)){d=k,s=y/3+e[y+2];break}if(32&k){t=7;break}return t=9,o.msg="invalid literal/length code",u=-3,i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);case 2:for(b=w;v<b;){if(m===0)return i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);u=0,m--,U|=(255&o.read_byte(S++))<<v,v+=8}l+=U&Z[b],U>>=b,v-=b,d=x,e=a,s=c,t=3;case 3:for(b=d;v<b;){if(m===0)return i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);u=0,m--,U|=(255&o.read_byte(S++))<<v,v+=8}if(y=3*(s+(U&Z[b])),U>>=e[y+1],v-=e[y+1],k=e[y],16&k){w=15&k,_=e[y+2],t=4;break}if(!(64&k)){d=k,s=y/3+e[y+2];break}return t=9,o.msg="invalid distance code",u=-3,i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);case 4:for(b=w;v<b;){if(m===0)return i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);u=0,m--,U|=(255&o.read_byte(S++))<<v,v+=8}_+=U&Z[b],U>>=b,v-=b,t=5;case 5:for(D=h-_;D<0;)D+=i.end;for(;l!==0;){if(A===0&&(h==i.end&&i.read!==0&&(h=0,A=h<i.read?i.read-h-1:i.end-h),A===0&&(i.write=h,u=i.inflate_flush(o,u),h=i.write,A=h<i.read?i.read-h-1:i.end-h,h==i.end&&i.read!==0&&(h=0,A=h<i.read?i.read-h-1:i.end-h),A===0)))return i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);i.win[h++]=i.win[D++],A--,D==i.end&&(D=0),l--}t=0;break;case 6:if(A===0&&(h==i.end&&i.read!==0&&(h=0,A=h<i.read?i.read-h-1:i.end-h),A===0&&(i.write=h,u=i.inflate_flush(o,u),h=i.write,A=h<i.read?i.read-h-1:i.end-h,h==i.end&&i.read!==0&&(h=0,A=h<i.read?i.read-h-1:i.end-h),A===0)))return i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);u=0,i.win[h++]=f,A--,t=0;break;case 7:if(v>7&&(v-=8,m++,S--),i.write=h,u=i.inflate_flush(o,u),h=i.write,A=h<i.read?i.read-h-1:i.end-h,i.read!=i.write)return i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);t=8;case 8:return u=1,i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);case 9:return u=-3,i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u);default:return u=-2,i.bitb=U,i.bitk=v,o.avail_in=m,o.total_in+=S-o.next_in_index,o.next_in_index=S,i.write=h,i.inflate_flush(o,u)}},n.free=function(){}}const Ge=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function on(n,t){const e=this;let r,a=0,l=0,s=0,d=0;const f=[0],w=[0],_=new sn;let g=0,x=new Int32Array(4320);const z=new We;e.bitk=0,e.bitb=0,e.win=new Uint8Array(t),e.end=t,e.read=0,e.write=0,e.reset=function(c,p){p&&(p[0]=0),a==6&&_.free(c),a=0,e.bitk=0,e.bitb=0,e.read=e.write=0},e.reset(n,null),e.inflate_flush=function(c,p){let i,o,u;return o=c.next_out_index,u=e.read,i=(u<=e.write?e.write:e.end)-u,i>c.avail_out&&(i=c.avail_out),i!==0&&p==-5&&(p=0),c.avail_out-=i,c.total_out+=i,c.next_out.set(e.win.subarray(u,u+i),o),o+=i,u+=i,u==e.end&&(u=0,e.write==e.end&&(e.write=0),i=e.write-u,i>c.avail_out&&(i=c.avail_out),i!==0&&p==-5&&(p=0),c.avail_out-=i,c.total_out+=i,c.next_out.set(e.win.subarray(u,u+i),o),o+=i,u+=i),c.next_out_index=o,e.read=u,p},e.proc=function(c,p){let i,o,u,b,y,k,m,h;for(b=c.next_in_index,y=c.avail_in,o=e.bitb,u=e.bitk,k=e.write,m=k<e.read?e.read-k-1:e.end-k;;){let A,D,U,v,S,E,O,W;switch(a){case 0:for(;u<3;){if(y===0)return e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);p=0,y--,o|=(255&c.read_byte(b++))<<u,u+=8}switch(i=7&o,g=1&i,i>>>1){case 0:o>>>=3,u-=3,i=7&u,o>>>=i,u-=i,a=1;break;case 1:A=[],D=[],U=[[]],v=[[]],We.inflate_trees_fixed(A,D,U,v),_.init(A[0],D[0],U[0],0,v[0],0),o>>>=3,u-=3,a=6;break;case 2:o>>>=3,u-=3,a=3;break;case 3:return o>>>=3,u-=3,a=9,c.msg="invalid block type",p=-3,e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p)}break;case 1:for(;u<32;){if(y===0)return e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);p=0,y--,o|=(255&c.read_byte(b++))<<u,u+=8}if((~o>>>16&65535)!=(65535&o))return a=9,c.msg="invalid stored block lengths",p=-3,e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);l=65535&o,o=u=0,a=l!==0?2:g!==0?7:0;break;case 2:if(y===0||m===0&&(k==e.end&&e.read!==0&&(k=0,m=k<e.read?e.read-k-1:e.end-k),m===0&&(e.write=k,p=e.inflate_flush(c,p),k=e.write,m=k<e.read?e.read-k-1:e.end-k,k==e.end&&e.read!==0&&(k=0,m=k<e.read?e.read-k-1:e.end-k),m===0)))return e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);if(p=0,i=l,i>y&&(i=y),i>m&&(i=m),e.win.set(c.read_buf(b,i),k),b+=i,y-=i,k+=i,m-=i,(l-=i)!=0)break;a=g!==0?7:0;break;case 3:for(;u<14;){if(y===0)return e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);p=0,y--,o|=(255&c.read_byte(b++))<<u,u+=8}if(s=i=16383&o,(31&i)>29||(i>>5&31)>29)return a=9,c.msg="too many length or distance symbols",p=-3,e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(h=0;h<i;h++)r[h]=0;o>>>=14,u-=14,d=0,a=4;case 4:for(;d<4+(s>>>10);){for(;u<3;){if(y===0)return e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);p=0,y--,o|=(255&c.read_byte(b++))<<u,u+=8}r[Ge[d++]]=7&o,o>>>=3,u-=3}for(;d<19;)r[Ge[d++]]=0;if(f[0]=7,i=z.inflate_trees_bits(r,f,w,x,c),i!=0)return(p=i)==-3&&(r=null,a=9),e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);d=0,a=5;case 5:for(;i=s,!(d>=258+(31&i)+(i>>5&31));){let F,C;for(i=f[0];u<i;){if(y===0)return e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);p=0,y--,o|=(255&c.read_byte(b++))<<u,u+=8}if(i=x[3*(w[0]+(o&Z[i]))+1],C=x[3*(w[0]+(o&Z[i]))+2],C<16)o>>>=i,u-=i,r[d++]=C;else{for(h=C==18?7:C-14,F=C==18?11:3;u<i+h;){if(y===0)return e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);p=0,y--,o|=(255&c.read_byte(b++))<<u,u+=8}if(o>>>=i,u-=i,F+=o&Z[h],o>>>=h,u-=h,h=d,i=s,h+F>258+(31&i)+(i>>5&31)||C==16&&h<1)return r=null,a=9,c.msg="invalid bit length repeat",p=-3,e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);C=C==16?r[h-1]:0;do r[h++]=C;while(--F!=0);d=h}}if(w[0]=-1,S=[],E=[],O=[],W=[],S[0]=9,E[0]=6,i=s,i=z.inflate_trees_dynamic(257+(31&i),1+(i>>5&31),r,S,E,O,W,x,c),i!=0)return i==-3&&(r=null,a=9),p=i,e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);_.init(S[0],E[0],x,O[0],x,W[0]),a=6;case 6:if(e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,(p=_.proc(e,c,p))!=1)return e.inflate_flush(c,p);if(p=0,_.free(c),b=c.next_in_index,y=c.avail_in,o=e.bitb,u=e.bitk,k=e.write,m=k<e.read?e.read-k-1:e.end-k,g===0){a=0;break}a=7;case 7:if(e.write=k,p=e.inflate_flush(c,p),k=e.write,m=k<e.read?e.read-k-1:e.end-k,e.read!=e.write)return e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);a=8;case 8:return p=1,e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);case 9:return p=-3,e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p);default:return p=-2,e.bitb=o,e.bitk=u,c.avail_in=y,c.total_in+=b-c.next_in_index,c.next_in_index=b,e.write=k,e.inflate_flush(c,p)}}},e.free=function(c){e.reset(c,null),e.win=null,x=null},e.set_dictionary=function(c,p,i){e.win.set(c.subarray(p,p+i),0),e.read=e.write=i},e.sync_point=function(){return a==1?1:0}}const X=13,ln=[0,0,255,255];function cn(){const n=this;function t(e){return e&&e.istate?(e.total_in=e.total_out=0,e.msg=null,e.istate.mode=7,e.istate.blocks.reset(e,null),0):-2}n.mode=0,n.method=0,n.was=[0],n.need=0,n.marker=0,n.wbits=0,n.inflateEnd=function(e){return n.blocks&&n.blocks.free(e),n.blocks=null,0},n.inflateInit=function(e,r){return e.msg=null,n.blocks=null,r<8||r>15?(n.inflateEnd(e),-2):(n.wbits=r,e.istate.blocks=new on(e,1<<r),t(e),0)},n.inflate=function(e,r){let a,l;if(!e||!e.istate||!e.next_in)return-2;const s=e.istate;for(r=r==4?-5:0,a=-5;;)switch(s.mode){case 0:if(e.avail_in===0)return a;if(a=r,e.avail_in--,e.total_in++,(15&(s.method=e.read_byte(e.next_in_index++)))!=8){s.mode=X,e.msg="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.wbits){s.mode=X,e.msg="invalid win size",s.marker=5;break}s.mode=1;case 1:if(e.avail_in===0)return a;if(a=r,e.avail_in--,e.total_in++,l=255&e.read_byte(e.next_in_index++),((s.method<<8)+l)%31!=0){s.mode=X,e.msg="incorrect header check",s.marker=5;break}if(!(32&l)){s.mode=7;break}s.mode=2;case 2:if(e.avail_in===0)return a;a=r,e.avail_in--,e.total_in++,s.need=(255&e.read_byte(e.next_in_index++))<<24&4278190080,s.mode=3;case 3:if(e.avail_in===0)return a;a=r,e.avail_in--,e.total_in++,s.need+=(255&e.read_byte(e.next_in_index++))<<16&16711680,s.mode=4;case 4:if(e.avail_in===0)return a;a=r,e.avail_in--,e.total_in++,s.need+=(255&e.read_byte(e.next_in_index++))<<8&65280,s.mode=5;case 5:return e.avail_in===0?a:(a=r,e.avail_in--,e.total_in++,s.need+=255&e.read_byte(e.next_in_index++),s.mode=6,2);case 6:return s.mode=X,e.msg="need dictionary",s.marker=0,-2;case 7:if(a=s.blocks.proc(e,a),a==-3){s.mode=X,s.marker=0;break}if(a==0&&(a=r),a!=1)return a;a=r,s.blocks.reset(e,s.was),s.mode=12;case 12:return e.avail_in=0,1;case X:return-3;default:return-2}},n.inflateSetDictionary=function(e,r,a){let l=0,s=a;if(!e||!e.istate||e.istate.mode!=6)return-2;const d=e.istate;return s>=1<<d.wbits&&(s=(1<<d.wbits)-1,l=a-s),d.blocks.set_dictionary(r,l,s),d.mode=7,0},n.inflateSync=function(e){let r,a,l,s,d;if(!e||!e.istate)return-2;const f=e.istate;if(f.mode!=X&&(f.mode=X,f.marker=0),(r=e.avail_in)===0)return-5;for(a=e.next_in_index,l=f.marker;r!==0&&l<4;)e.read_byte(a)==ln[l]?l++:l=e.read_byte(a)!==0?0:4-l,a++,r--;return e.total_in+=a-e.next_in_index,e.next_in_index=a,e.avail_in=r,f.marker=l,l!=4?-3:(s=e.total_in,d=e.total_out,t(e),e.total_in=s,e.total_out=d,f.mode=7,0)},n.inflateSyncPoint=function(e){return e&&e.istate&&e.istate.blocks?e.istate.blocks.sync_point():-2}}function pt(){}pt.prototype={inflateInit(n){const t=this;return t.istate=new cn,n||(n=15),t.istate.inflateInit(t,n)},inflate(n){const t=this;return t.istate?t.istate.inflate(t,n):-2},inflateEnd(){const n=this;if(!n.istate)return-2;const t=n.istate.inflateEnd(n);return n.istate=null,t},inflateSync(){const n=this;return n.istate?n.istate.inflateSync(n):-2},inflateSetDictionary(n,t){const e=this;return e.istate?e.istate.inflateSetDictionary(e,n,t):-2},read_byte(n){return this.next_in[n]},read_buf(n,t){return this.next_in.subarray(n,n+t)}};const ie=4294967295,re=65535,Je=33639248,Qe=101075792,ae=22,H=void 0,te="undefined",we="function";class Xe{constructor(t){return class extends TransformStream{constructor(e,r){const a=new t(r);super({transform(l,s){s.enqueue(a.append(l))},flush(l){const s=a.flush();s&&l.enqueue(s)}})}}}}let mt=2;try{typeof navigator!=te&&navigator.hardwareConcurrency&&(mt=navigator.hardwareConcurrency)}catch{}const un={chunkSize:524288,maxWorkers:mt,terminateWorkerTimeout:5e3,useWebWorkers:!0,useCompressionStream:!0,workerScripts:H,CompressionStreamNative:typeof CompressionStream!=te&&CompressionStream,DecompressionStreamNative:typeof DecompressionStream!=te&&DecompressionStream},ee=Object.assign({},un);function fn(n){const{baseURL:t,chunkSize:e,maxWorkers:r,terminateWorkerTimeout:a,useCompressionStream:l,useWebWorkers:s,Deflate:d,Inflate:f,CompressionStream:w,DecompressionStream:_,workerScripts:g}=n;if(Y("baseURL",t),Y("chunkSize",e),Y("maxWorkers",r),Y("terminateWorkerTimeout",a),Y("useCompressionStream",l),Y("useWebWorkers",s),d&&(ee.CompressionStream=new Xe(d)),f&&(ee.DecompressionStream=new Xe(f)),Y("CompressionStream",w),Y("DecompressionStream",_),g!==H){const{deflate:x,inflate:z}=g;if((x||z)&&(ee.workerScripts||(ee.workerScripts={})),x){if(!Array.isArray(x))throw new Error("workerScripts.deflate must be an array");ee.workerScripts.deflate=x}if(z){if(!Array.isArray(z))throw new Error("workerScripts.inflate must be an array");ee.workerScripts.inflate=z}}}function Y(n,t){t!==H&&(ee[n]=t)}const yt=[];for(let n=0;n<256;n++){let t=n;for(let e=0;e<8;e++)1&t?t=t>>>1^3988292384:t>>>=1;yt[n]=t}class xe{constructor(t){this.crc=t||-1}append(t){let e=0|this.crc;for(let r=0,a=0|t.length;r<a;r++)e=e>>>8^yt[255&(e^t[r])];this.crc=e}get(){return~this.crc}}class xt extends TransformStream{constructor(){let t;const e=new xe;super({transform(r,a){e.append(r),a.enqueue(r)},flush(){const r=new Uint8Array(4);new DataView(r.buffer).setUint32(0,e.get()),t.value=r}}),t=this}}const q={concat(n,t){if(n.length===0||t.length===0)return n.concat(t);const e=n[n.length-1],r=q.getPartial(e);return r===32?n.concat(t):q._shiftRight(t,r,0|e,n.slice(0,n.length-1))},bitLength(n){const t=n.length;if(t===0)return 0;const e=n[t-1];return 32*(t-1)+q.getPartial(e)},clamp(n,t){if(32*n.length<t)return n;const e=(n=n.slice(0,Math.ceil(t/32))).length;return t&=31,e>0&&t&&(n[e-1]=q.partial(t,n[e-1]&2147483648>>t-1,1)),n},partial:(n,t,e)=>n===32?t:(e?0|t:t<<32-n)+1099511627776*n,getPartial:n=>Math.round(n/1099511627776)||32,_shiftRight(n,t,e,r){for(r===void 0&&(r=[]);t>=32;t-=32)r.push(e),e=0;if(t===0)return r.concat(n);for(let s=0;s<n.length;s++)r.push(e|n[s]>>>t),e=n[s]<<32-t;const a=n.length?n[n.length-1]:0,l=q.getPartial(a);return r.push(q.partial(t+l&31,t+l>32?e:r.pop(),1)),r}},ge={bytes:{fromBits(n){const t=q.bitLength(n)/8,e=new Uint8Array(t);let r;for(let a=0;a<t;a++)3&a||(r=n[a/4]),e[a]=r>>>24,r<<=8;return e},toBits(n){const t=[];let e,r=0;for(e=0;e<n.length;e++)r=r<<8|n[e],3&~e||(t.push(r),r=0);return 3&e&&t.push(q.partial(8*(3&e),r)),t}}},dn={sha1:class{constructor(n){const t=this;t.blockSize=512,t._init=[1732584193,4023233417,2562383102,271733878,3285377520],t._key=[1518500249,1859775393,2400959708,3395469782],n?(t._h=n._h.slice(0),t._buffer=n._buffer.slice(0),t._length=n._length):t.reset()}reset(){const n=this;return n._h=n._init.slice(0),n._buffer=[],n._length=0,n}update(n){const t=this;typeof n=="string"&&(n=ge.utf8String.toBits(n));const e=t._buffer=q.concat(t._buffer,n),r=t._length,a=t._length=r+q.bitLength(n);if(a>9007199254740991)throw new Error("Cannot hash more than 2^53 - 1 bits");const l=new Uint32Array(e);let s=0;for(let d=t.blockSize+r-(t.blockSize+r&t.blockSize-1);d<=a;d+=t.blockSize)t._block(l.subarray(16*s,16*(s+1))),s+=1;return e.splice(0,16*s),t}finalize(){const n=this;let t=n._buffer;const e=n._h;t=q.concat(t,[q.partial(1,1)]);for(let r=t.length+2;15&r;r++)t.push(0);for(t.push(Math.floor(n._length/4294967296)),t.push(0|n._length);t.length;)n._block(t.splice(0,16));return n.reset(),e}_f(n,t,e,r){return n<=19?t&e|~t&r:n<=39?t^e^r:n<=59?t&e|t&r|e&r:n<=79?t^e^r:void 0}_S(n,t){return t<<n|t>>>32-n}_block(n){const t=this,e=t._h,r=Array(80);for(let w=0;w<16;w++)r[w]=n[w];let a=e[0],l=e[1],s=e[2],d=e[3],f=e[4];for(let w=0;w<=79;w++){w>=16&&(r[w]=t._S(1,r[w-3]^r[w-8]^r[w-14]^r[w-16]));const _=t._S(5,a)+t._f(w,l,s,d)+f+r[w]+t._key[Math.floor(w/20)]|0;f=d,d=s,s=t._S(30,l),l=a,a=_}e[0]=e[0]+a|0,e[1]=e[1]+l|0,e[2]=e[2]+s|0,e[3]=e[3]+d|0,e[4]=e[4]+f|0}}},hn={aes:class{constructor(n){const t=this;t._tables=[[[],[],[],[],[]],[[],[],[],[],[]]],t._tables[0][0][0]||t._precompute();const e=t._tables[0][4],r=t._tables[1],a=n.length;let l,s,d,f=1;if(a!==4&&a!==6&&a!==8)throw new Error("invalid aes key size");for(t._key=[s=n.slice(0),d=[]],l=a;l<4*a+28;l++){let w=s[l-1];(l%a==0||a===8&&l%a==4)&&(w=e[w>>>24]<<24^e[w>>16&255]<<16^e[w>>8&255]<<8^e[255&w],l%a==0&&(w=w<<8^w>>>24^f<<24,f=f<<1^283*(f>>7))),s[l]=s[l-a]^w}for(let w=0;l;w++,l--){const _=s[3&w?l:l-4];d[w]=l<=4||w<4?_:r[0][e[_>>>24]]^r[1][e[_>>16&255]]^r[2][e[_>>8&255]]^r[3][e[255&_]]}}encrypt(n){return this._crypt(n,0)}decrypt(n){return this._crypt(n,1)}_precompute(){const n=this._tables[0],t=this._tables[1],e=n[4],r=t[4],a=[],l=[];let s,d,f,w;for(let _=0;_<256;_++)l[(a[_]=_<<1^283*(_>>7))^_]=_;for(let _=s=0;!e[_];_^=d||1,s=l[s]||1){let g=s^s<<1^s<<2^s<<3^s<<4;g=g>>8^255&g^99,e[_]=g,r[g]=_,w=a[f=a[d=a[_]]];let x=16843009*w^65537*f^257*d^16843008*_,z=257*a[g]^16843008*g;for(let c=0;c<4;c++)n[c][_]=z=z<<24^z>>>8,t[c][g]=x=x<<24^x>>>8}for(let _=0;_<5;_++)n[_]=n[_].slice(0),t[_]=t[_].slice(0)}_crypt(n,t){if(n.length!==4)throw new Error("invalid aes block size");const e=this._key[t],r=e.length/4-2,a=[0,0,0,0],l=this._tables[t],s=l[0],d=l[1],f=l[2],w=l[3],_=l[4];let g,x,z,c=n[0]^e[0],p=n[t?3:1]^e[1],i=n[2]^e[2],o=n[t?1:3]^e[3],u=4;for(let b=0;b<r;b++)g=s[c>>>24]^d[p>>16&255]^f[i>>8&255]^w[255&o]^e[u],x=s[p>>>24]^d[i>>16&255]^f[o>>8&255]^w[255&c]^e[u+1],z=s[i>>>24]^d[o>>16&255]^f[c>>8&255]^w[255&p]^e[u+2],o=s[o>>>24]^d[c>>16&255]^f[p>>8&255]^w[255&i]^e[u+3],u+=4,c=g,p=x,i=z;for(let b=0;b<4;b++)a[t?3&-b:b]=_[c>>>24]<<24^_[p>>16&255]<<16^_[i>>8&255]<<8^_[255&o]^e[u++],g=c,c=p,p=i,i=o,o=g;return a}}},wn={getRandomValues(n){const t=new Uint32Array(n.buffer),e=r=>{let a=987654321;const l=4294967295;return function(){return a=36969*(65535&a)+(a>>16)&l,(((a<<16)+(r=18e3*(65535&r)+(r>>16)&l)&l)/4294967296+.5)*(Math.random()>.5?1:-1)}};for(let r,a=0;a<n.length;a+=4){const l=e(4294967296*(r||Math.random()));r=987654071*l(),t[a/4]=4294967296*l()|0}return n}},_n={ctrGladman:class{constructor(n,t){this._prf=n,this._initIv=t,this._iv=t}reset(){this._iv=this._initIv}update(n){return this.calculate(this._prf,n,this._iv)}incWord(n){if(255&~(n>>24))n+=1<<24;else{let t=n>>16&255,e=n>>8&255,r=255&n;t===255?(t=0,e===255?(e=0,r===255?r=0:++r):++e):++t,n=0,n+=t<<16,n+=e<<8,n+=r}return n}incCounter(n){(n[0]=this.incWord(n[0]))===0&&(n[1]=this.incWord(n[1]))}calculate(n,t,e){let r;if(!(r=t.length))return[];const a=q.bitLength(t);for(let l=0;l<r;l+=4){this.incCounter(e);const s=n.encrypt(e);t[l]^=s[0],t[l+1]^=s[1],t[l+2]^=s[2],t[l+3]^=s[3]}return q.clamp(t,a)}}},se={importKey:n=>new se.hmacSha1(ge.bytes.toBits(n)),pbkdf2(n,t,e,r){if(e=e||1e4,r<0||e<0)throw new Error("invalid params to pbkdf2");const a=1+(r>>5)<<2;let l,s,d,f,w;const _=new ArrayBuffer(a),g=new DataView(_);let x=0;const z=q;for(t=ge.bytes.toBits(t),w=1;x<(a||1);w++){for(l=s=n.encrypt(z.concat(t,[w])),d=1;d<e;d++)for(s=n.encrypt(s),f=0;f<s.length;f++)l[f]^=s[f];for(d=0;x<(a||1)&&d<l.length;d++)g.setInt32(x,l[d]),x+=4}return _.slice(0,r/8)},hmacSha1:class{constructor(n){const t=this,e=t._hash=dn.sha1,r=[[],[]];t._baseHash=[new e,new e];const a=t._baseHash[0].blockSize/32;n.length>a&&(n=new e().update(n).finalize());for(let l=0;l<a;l++)r[0][l]=909522486^n[l],r[1][l]=1549556828^n[l];t._baseHash[0].update(r[0]),t._baseHash[1].update(r[1]),t._resultHash=new e(t._baseHash[0])}reset(){const n=this;n._resultHash=new n._hash(n._baseHash[0]),n._updated=!1}update(n){this._updated=!0,this._resultHash.update(n)}digest(){const n=this,t=n._resultHash.finalize(),e=new n._hash(n._baseHash[1]).update(t).finalize();return n.reset(),e}encrypt(n){if(this._updated)throw new Error("encrypt on already updated hmac called!");return this.update(n),this.digest(n)}}},bn=typeof crypto!=te&&typeof crypto.getRandomValues==we,gt="Invalid password",kt="Invalid signature",Pe="zipjs-abort-check-password";function vt(n){return bn?crypto.getRandomValues(n):wn.getRandomValues(n)}const oe=16,St={name:"PBKDF2"},pn=Object.assign({hash:{name:"HMAC"}},St),Ue=Object.assign({iterations:1e3,hash:{name:"SHA-1"}},St),mn=["deriveBits"],ue=[8,12,16],ce=[16,24,32],$=10,yn=[0,0,0,0],Se=typeof crypto!=te,fe=Se&&crypto.subtle,zt=Se&&typeof fe!=te,J=ge.bytes,xn=hn.aes,gn=_n.ctrGladman,kn=se.hmacSha1;let Ye=Se&&zt&&typeof fe.importKey==we,$e=Se&&zt&&typeof fe.deriveBits==we;class vn extends TransformStream{constructor({password:t,rawPassword:e,signed:r,encryptionStrength:a,checkPasswordOnly:l}){super({start(){Object.assign(this,{ready:new Promise(s=>this.resolveReady=s),password:Dt(t,e),signed:r,strength:a-1,pending:new Uint8Array})},async transform(s,d){const f=this,{password:w,strength:_,resolveReady:g,ready:x}=f;w?(await async function(c,p,i,o){const u=await Ut(c,p,i,G(o,0,ue[p])),b=G(o,ue[p]);if(u[0]!=b[0]||u[1]!=b[1])throw new Error(gt)}(f,_,w,G(s,0,ue[_]+2)),s=G(s,ue[_]+2),l?d.error(new Error(Pe)):g()):await x;const z=new Uint8Array(s.length-$-(s.length-$)%oe);d.enqueue(At(f,s,z,0,$,!0))},async flush(s){const{signed:d,ctr:f,hmac:w,pending:_,ready:g}=this;if(w&&f){await g;const x=G(_,0,_.length-$),z=G(_,_.length-$);let c=new Uint8Array;if(x.length){const p=he(J,x);w.update(p);const i=f.update(p);c=de(J,i)}if(d){const p=G(de(J,w.digest()),0,$);for(let i=0;i<$;i++)if(p[i]!=z[i])throw new Error(kt)}s.enqueue(c)}}})}}class Sn extends TransformStream{constructor({password:t,rawPassword:e,encryptionStrength:r}){let a;super({start(){Object.assign(this,{ready:new Promise(l=>this.resolveReady=l),password:Dt(t,e),strength:r-1,pending:new Uint8Array})},async transform(l,s){const d=this,{password:f,strength:w,resolveReady:_,ready:g}=d;let x=new Uint8Array;f?(x=await async function(c,p,i){const o=vt(new Uint8Array(ue[p])),u=await Ut(c,p,i,o);return Ce(o,u)}(d,w,f),_()):await g;const z=new Uint8Array(x.length+l.length-l.length%oe);z.set(x,0),s.enqueue(At(d,l,z,x.length,0))},async flush(l){const{ctr:s,hmac:d,pending:f,ready:w}=this;if(d&&s){await w;let _=new Uint8Array;if(f.length){const g=s.update(he(J,f));d.update(g),_=de(J,g)}a.signature=de(J,d.digest()).slice(0,$),l.enqueue(Ce(_,a.signature))}}}),a=this}}function At(n,t,e,r,a,l){const{ctr:s,hmac:d,pending:f}=n,w=t.length-a;let _;for(f.length&&(t=Ce(f,t),e=function(g,x){if(x&&x>g.length){const z=g;(g=new Uint8Array(x)).set(z,0)}return g}(e,w-w%oe)),_=0;_<=w-oe;_+=oe){const g=he(J,G(t,_,_+oe));l&&d.update(g);const x=s.update(g);l||d.update(x),e.set(de(J,x),_+r)}return n.pending=G(t,_),e}async function Ut(n,t,e,r){n.password=null;const a=await async function(_,g,x,z,c){if(!Ye)return se.importKey(g);try{return await fe.importKey(_,g,x,z,c)}catch{return Ye=!1,se.importKey(g)}}("raw",e,pn,!1,mn),l=await async function(_,g,x){if(!$e)return se.pbkdf2(g,_.salt,Ue.iterations,x);try{return await fe.deriveBits(_,g,x)}catch{return $e=!1,se.pbkdf2(g,_.salt,Ue.iterations,x)}}(Object.assign({salt:r},Ue),a,8*(2*ce[t]+2)),s=new Uint8Array(l),d=he(J,G(s,0,ce[t])),f=he(J,G(s,ce[t],2*ce[t])),w=G(s,2*ce[t]);return Object.assign(n,{keys:{key:d,authentication:f,passwordVerification:w},ctr:new gn(new xn(d),Array.from(yn)),hmac:new kn(f)}),w}function Dt(n,t){return t===H?function(e){if(typeof TextEncoder==te){e=unescape(encodeURIComponent(e));const r=new Uint8Array(e.length);for(let a=0;a<r.length;a++)r[a]=e.charCodeAt(a);return r}return new TextEncoder().encode(e)}(n):t}function Ce(n,t){let e=n;return n.length+t.length&&(e=new Uint8Array(n.length+t.length),e.set(n,0),e.set(t,n.length)),e}function G(n,t,e){return n.subarray(t,e)}function de(n,t){return n.fromBits(t)}function he(n,t){return n.toBits(t)}const ke=12;class zn extends TransformStream{constructor({password:t,passwordVerification:e,checkPasswordOnly:r}){super({start(){Object.assign(this,{password:t,passwordVerification:e}),Et(this,t)},transform(a,l){const s=this;if(s.password){const d=et(s,a.subarray(0,ke));if(s.password=null,d[11]!=s.passwordVerification)throw new Error(gt);a=a.subarray(ke)}r?l.error(new Error(Pe)):l.enqueue(et(s,a))}})}}class An extends TransformStream{constructor({password:t,passwordVerification:e}){super({start(){Object.assign(this,{password:t,passwordVerification:e}),Et(this,t)},transform(r,a){const l=this;let s,d;if(l.password){l.password=null;const f=vt(new Uint8Array(ke));f[11]=l.passwordVerification,s=new Uint8Array(r.length+f.length),s.set(tt(l,f),0),d=ke}else s=new Uint8Array(r.length),d=0;s.set(tt(l,r),d),a.enqueue(s)}})}}function et(n,t){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=Tt(n)^t[r],Re(n,e[r]);return e}function tt(n,t){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=Tt(n)^t[r],Re(n,t[r]);return e}function Et(n,t){const e=[305419896,591751049,878082192];Object.assign(n,{keys:e,crcKey0:new xe(e[0]),crcKey2:new xe(e[2])});for(let r=0;r<t.length;r++)Re(n,t.charCodeAt(r))}function Re(n,t){let[e,r,a]=n.keys;n.crcKey0.append([t]),e=~n.crcKey0.get(),r=nt(Math.imul(nt(r+Ft(e)),134775813)+1),n.crcKey2.append([r>>>24]),a=~n.crcKey2.get(),n.keys=[e,r,a]}function Tt(n){const t=2|n.keys[2];return Ft(Math.imul(t,1^t)>>>8)}function Ft(n){return 255&n}function nt(n){return 4294967295&n}const rt="deflate-raw";class Un extends TransformStream{constructor(t,{chunkSize:e,CompressionStream:r,CompressionStreamNative:a}){super({});const{compressed:l,encrypted:s,useCompressionStream:d,zipCrypto:f,signed:w,level:_}=t,g=this;let x,z,c=Ot(super.readable);s&&!f||!w||(x=new xt,c=Q(c,x)),l&&(c=Ct(c,d,{level:_,chunkSize:e},a,r)),s&&(f?c=Q(c,new An(t)):(z=new Sn(t),c=Q(c,z))),Wt(g,c,()=>{let p;s&&!f&&(p=z.signature),s&&!f||!w||(p=new DataView(x.value.buffer).getUint32(0)),g.signature=p})}}class Dn extends TransformStream{constructor(t,{chunkSize:e,DecompressionStream:r,DecompressionStreamNative:a}){super({});const{zipCrypto:l,encrypted:s,signed:d,signature:f,compressed:w,useCompressionStream:_}=t;let g,x,z=Ot(super.readable);s&&(l?z=Q(z,new zn(t)):(x=new vn(t),z=Q(z,x))),w&&(z=Ct(z,_,{chunkSize:e},a,r)),s&&!l||!d||(g=new xt,z=Q(z,g)),Wt(this,z,()=>{if((!s||l)&&d){const c=new DataView(g.value.buffer);if(f!=c.getUint32(0,!1))throw new Error(kt)}})}}function Ot(n){return Q(n,new TransformStream({transform(t,e){t&&t.length&&e.enqueue(t)}}))}function Wt(n,t,e){t=Q(t,new TransformStream({flush:e})),Object.defineProperty(n,"readable",{get:()=>t})}function Ct(n,t,e,r,a){try{n=Q(n,new(t&&r?r:a)(rt,e))}catch{if(!t)return n;try{n=Q(n,new a(rt,e))}catch{return n}}return n}function Q(n,t){return n.pipeThrough(t)}const En="message",Tn="start",Fn="pull",it="data",at="close",jt="inflate";class On extends TransformStream{constructor(t,e){super({});const r=this,{codecType:a}=t;let l;a.startsWith("deflate")?l=Un:a.startsWith(jt)&&(l=Dn);let s=0,d=0;const f=new l(t,e),w=super.readable,_=new TransformStream({transform(x,z){x&&x.length&&(d+=x.length,z.enqueue(x))},flush(){Object.assign(r,{inputSize:d})}}),g=new TransformStream({transform(x,z){x&&x.length&&(s+=x.length,z.enqueue(x))},flush(){const{signature:x}=f;Object.assign(r,{signature:x,outputSize:s,inputSize:d})}});Object.defineProperty(r,"readable",{get:()=>w.pipeThrough(_).pipeThrough(f).pipeThrough(g)})}}class Wn extends TransformStream{constructor(t){let e;super({transform:function r(a,l){if(e){const s=new Uint8Array(e.length+a.length);s.set(e),s.set(a,e.length),a=s,e=null}a.length>t?(l.enqueue(a.slice(0,t)),r(a.slice(t),l)):e=a},flush(r){e&&e.length&&r.enqueue(e)}})}}let Mt=typeof Worker!=te;class De{constructor(t,{readable:e,writable:r},{options:a,config:l,streamOptions:s,useWebWorkers:d,transferStreams:f,scripts:w},_){const{signal:g}=s;return Object.assign(t,{busy:!0,readable:e.pipeThrough(new Wn(l.chunkSize)).pipeThrough(new Cn(e,s),{signal:g}),writable:r,options:Object.assign({},a),scripts:w,transferStreams:f,terminate:()=>new Promise(x=>{const{worker:z,busy:c}=t;z?(c?t.resolveTerminated=x:(z.terminate(),x()),t.interface=null):x()}),onTaskFinished(){const{resolveTerminated:x}=t;x&&(t.resolveTerminated=null,t.terminated=!0,t.worker.terminate(),x()),t.busy=!1,_(t)}}),(d&&Mt?jn:Lt)(t,l)}}class Cn extends TransformStream{constructor(t,{onstart:e,onprogress:r,size:a,onend:l}){let s=0;super({async start(){e&&await Ee(e,a)},async transform(d,f){s+=d.length,r&&await Ee(r,s,a),f.enqueue(d)},async flush(){t.size=s,l&&await Ee(l,s)}})}}async function Ee(n,...t){try{await n(...t)}catch{}}function Lt(n,t){return{run:()=>async function({options:e,readable:r,writable:a,onTaskFinished:l},s){try{const d=new On(e,s);await r.pipeThrough(d).pipeTo(a,{preventClose:!0,preventAbort:!0});const{signature:f,inputSize:w,outputSize:_}=d;return{signature:f,inputSize:w,outputSize:_}}finally{l()}}(n,t)}}function jn(n,t){const{baseURL:e,chunkSize:r}=t;if(!n.interface){let a;try{a=function(l,s,d){const f={type:"module"};let w,_;typeof l==we&&(l=l());try{w=new URL(l,s)}catch{w=l}if(st)try{_=new Worker(w)}catch{st=!1,_=new Worker(w,f)}else _=new Worker(w,f);return _.addEventListener(En,g=>async function({data:x},z){const{type:c,value:p,messageId:i,result:o,error:u}=x,{reader:b,writer:y,resolveResult:k,rejectResult:m,onTaskFinished:h}=z;try{if(u){const{message:D,stack:U,code:v,name:S}=u,E=new Error(D);Object.assign(E,{stack:U,code:v,name:S}),A(E)}else{if(c==Fn){const{value:D,done:U}=await b.read();pe({type:it,value:D,done:U,messageId:i},z)}c==it&&(await y.ready,await y.write(new Uint8Array(p)),pe({type:"ack",messageId:i},z)),c==at&&A(null,o)}}catch(D){pe({type:at,messageId:i},z),A(D)}function A(D,U){D?m(D):k(U),y&&y.releaseLock(),h()}}(g,d)),_}(n.scripts[0],e,n)}catch{return Mt=!1,Lt(n,t)}Object.assign(n,{worker:a,interface:{run:()=>async function(l,s){let d,f;const w=new Promise((o,u)=>{d=o,f=u});Object.assign(l,{reader:null,writer:null,resolveResult:d,rejectResult:f,result:w});const{readable:_,options:g,scripts:x}=l,{writable:z,closed:c}=function(o){let u;const b=new Promise(k=>u=k);return{writable:new WritableStream({async write(k){const m=o.getWriter();await m.ready,await m.write(k),m.releaseLock()},close(){u()},abort:k=>o.getWriter().abort(k)}),closed:b}}(l.writable),p=pe({type:Tn,scripts:x.slice(1),options:g,config:s,readable:_,writable:z},l);p||Object.assign(l,{reader:_.getReader(),writer:z.getWriter()});const i=await w;return p||await z.getWriter().close(),await c,i}(n,{chunkSize:r})}})}return n.interface}let st=!0,ot=!0;function pe(n,{worker:t,writer:e,onTaskFinished:r,transferStreams:a}){try{let{value:l,readable:s,writable:d}=n;const f=[];if(l&&(l.byteLength<l.buffer.byteLength?n.value=l.buffer.slice(0,l.byteLength):n.value=l.buffer,f.push(n.value)),a&&ot?(s&&f.push(s),d&&f.push(d)):n.readable=n.writable=null,f.length)try{return t.postMessage(n,f),!0}catch{ot=!1,n.readable=n.writable=null,t.postMessage(n)}else t.postMessage(n)}catch(l){throw e&&e.releaseLock(),r(),l}}let ne=[];const Te=[];let lt=0;async function Mn(n,t){const{options:e,config:r}=t,{transferStreams:a,useWebWorkers:l,useCompressionStream:s,codecType:d,compressed:f,signed:w,encrypted:_}=e,{workerScripts:g,maxWorkers:x}=r;t.transferStreams=a||a===H;const z=!(f||w||_||t.transferStreams);return t.useWebWorkers=!z&&(l||l===H&&r.useWebWorkers),t.scripts=t.useWebWorkers&&g?g[d]:[],e.useCompressionStream=s||s===H&&r.useCompressionStream,(await async function(){const p=ne.find(i=>!i.busy);if(p)return ct(p),new De(p,n,t,c);if(ne.length<x){const i={indexWorker:lt};return lt++,ne.push(i),new De(i,n,t,c)}return new Promise(i=>Te.push({resolve:i,stream:n,workerOptions:t}))}()).run();function c(p){if(Te.length){const[{resolve:i,stream:o,workerOptions:u}]=Te.splice(0,1);i(new De(p,o,u,c))}else p.worker?(ct(p),function(i,o){const{config:u}=o,{terminateWorkerTimeout:b}=u;Number.isFinite(b)&&b>=0&&(i.terminated?i.terminated=!1:i.terminateTimeout=setTimeout(async()=>{ne=ne.filter(y=>y!=i);try{await i.terminate()}catch{}},b))}(p,t)):ne=ne.filter(i=>i!=p)}}function ct(n){const{terminateTimeout:t}=n;t&&(clearTimeout(t),n.terminateTimeout=null)}const Ln=65536,Pt="writable";class Be{constructor(){this.size=0}init(){this.initialized=!0}}class Rt extends Be{get readable(){const t=this,{chunkSize:e=Ln}=t,r=new ReadableStream({start(){this.chunkOffset=0},async pull(a){const{offset:l=0,size:s,diskNumberStart:d}=r,{chunkOffset:f}=this;a.enqueue(await N(t,l+f,Math.min(e,s-f),d)),f+e>s?a.close():this.chunkOffset+=e}});return r}}class Pn extends Rt{constructor(t){super(),Object.assign(this,{blob:t,size:t.size})}async readUint8Array(t,e){const r=this,a=t+e;let s=await(t||a<r.size?r.blob.slice(t,a):r.blob).arrayBuffer();return s.byteLength>e&&(s=s.slice(t,a)),new Uint8Array(s)}}class Rn extends Be{constructor(t){super();const e=new TransformStream,r=[];t&&r.push(["Content-Type",t]),Object.defineProperty(this,Pt,{get:()=>e.writable}),this.blob=new Response(e.readable,{headers:r}).blob()}getData(){return this.blob}}class Xn extends Rn{constructor(t){super(t),Object.assign(this,{encoding:t,utf8:!t||t.toLowerCase()=="utf-8"})}async getData(){const{encoding:t,utf8:e}=this,r=await super.getData();if(r.text&&e)return r.text();{const a=new FileReader;return new Promise((l,s)=>{Object.assign(a,{onload:({target:d})=>l(d.result),onerror:()=>s(a.error)}),a.readAsText(r,t)})}}}class Bn extends Rt{constructor(t){super(),this.readers=t}async init(){const t=this,{readers:e}=t;t.lastDiskNumber=0,t.lastDiskOffset=0,await Promise.all(e.map(async(r,a)=>{await r.init(),a!=e.length-1&&(t.lastDiskOffset+=r.size),t.size+=r.size})),super.init()}async readUint8Array(t,e,r=0){const a=this,{readers:l}=this;let s,d=r;d==-1&&(d=l.length-1);let f=t;for(;f>=l[d].size;)f-=l[d].size,d++;const w=l[d],_=w.size;if(f+e<=_)s=await N(w,f,e);else{const g=_-f;s=new Uint8Array(e),s.set(await N(w,f,g)),s.set(await a.readUint8Array(t+g,e-g,r),g)}return a.lastDiskNumber=Math.max(d,a.lastDiskNumber),s}}class ut extends Be{constructor(t,e=4294967295){super();const r=this;let a,l,s;Object.assign(r,{diskNumber:0,diskOffset:0,size:0,maxSize:e,availableSize:e});const d=new WritableStream({async write(_){const{availableSize:g}=r;if(s)_.length>=g?(await f(_.slice(0,g)),await w(),r.diskOffset+=a.size,r.diskNumber++,s=null,await this.write(_.slice(g))):await f(_);else{const{value:x,done:z}=await t.next();if(z&&!x)throw new Error("Writer iterator completed too soon");a=x,a.size=0,a.maxSize&&(r.maxSize=a.maxSize),r.availableSize=r.maxSize,await ve(a),l=x.writable,s=l.getWriter(),await this.write(_)}},async close(){await s.ready,await w()}});async function f(_){const g=_.length;g&&(await s.ready,await s.write(_),a.size+=g,r.size+=g,r.availableSize-=g)}async function w(){l.size=a.size,await s.close()}Object.defineProperty(r,Pt,{get:()=>d})}}async function ve(n,t){if(!n.init||n.initialized)return Promise.resolve();await n.init(t)}function In(n){return Array.isArray(n)&&(n=new Bn(n)),n instanceof ReadableStream&&(n={readable:n}),n}function N(n,t,e,r){return n.readUint8Array(t,e,r)}const Bt="\0☺☻♥♦♣♠•◘○◙♂♀♪♫☼►◄↕‼¶§▬↨↑↓→←∟↔▲▼ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~⌂ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ".split(""),Nn=Bt.length==256;function me(n,t){return t&&t.trim().toLowerCase()=="cp437"?function(e){if(Nn){let r="";for(let a=0;a<e.length;a++)r+=Bt[e[a]];return r}return new TextDecoder().decode(e)}(n):new TextDecoder(t).decode(n)}const It="filename",Nt="rawFilename",Vt="comment",qt="rawComment",Ht="uncompressedSize",Kt="compressedSize",Zt="offset",je="diskNumberStart",Me="lastModDate",Le="rawLastModDate",Gt="lastAccessDate",Vn="rawLastAccessDate",Jt="creationDate",qn="rawCreationDate",Hn=[It,Nt,Kt,Ht,Me,Le,Vt,qt,Gt,Jt,Zt,je,je,"internalFileAttribute","externalFileAttribute","msDosCompatible","zip64","encrypted","version","versionMadeBy","zipCrypto","directory","bitFlag","signature","filenameUTF8","commentUTF8","compressionMethod","extraField","rawExtraField","extraFieldZip64","extraFieldUnicodePath","extraFieldUnicodeComment","extraFieldAES","extraFieldNTFS","extraFieldExtendedTimestamp"];class ft{constructor(t){Hn.forEach(e=>this[e]=t[e])}}const Fe="File format is not recognized",Kn="Zip64 extra field not found",dt="Compression method not supported",ht="Split zip file",wt="utf-8",_t="cp437",Zn=[[Ht,ie],[Kt,ie],[Zt,ie],[je,re]],Gn={[re]:{getValue:P,bytes:4},[ie]:{getValue:ye,bytes:8}};class Yn{constructor(t,e={}){Object.assign(this,{reader:In(t),options:e,config:ee})}async*getEntriesGenerator(t={}){const e=this;let{reader:r}=e;const{config:a}=e;if(await ve(r),r.size!==H&&r.readUint8Array||(r=new Pn(await new Response(r.readable).blob()),await ve(r)),r.size<ae)throw new Error(Fe);r.chunkSize=function(U){return Math.max(U.chunkSize,64)}(a);const l=await async function(U,v,S,E,O){const W=new Uint8Array(4);(function(j,K,T){j.setUint32(K,T,!0)})(B(W),0,v);const F=E+O;return await C(E)||await C(Math.min(F,S));async function C(j){const K=S-j,T=await N(U,K,j);for(let R=T.length-E;R>=0;R--)if(T[R]==W[0]&&T[R+1]==W[1]&&T[R+2]==W[2]&&T[R+3]==W[3])return{offset:K+R,buffer:T.slice(R,R+E).buffer}}}(r,101010256,r.size,ae,1048560);if(!l)throw P(B(await N(r,0,4)))==134695760?new Error(ht):new Error("End of central directory not found");const s=B(l);let d=P(s,12),f=P(s,16);const w=l.offset,_=I(s,20),g=w+ae+_;let x=I(s,4);const z=r.lastDiskNumber||0;let c=I(s,6),p=I(s,8),i=0,o=0;if(f==ie||d==ie||p==re||c==re){const U=B(await N(r,l.offset-20,20));if(P(U,0)==117853008){f=ye(U,8);let v=await N(r,f,56,-1),S=B(v);const E=l.offset-20-56;if(P(S,0)!=Qe&&f!=E){const O=f;f=E,i=f-O,v=await N(r,f,56,-1),S=B(v)}if(P(S,0)!=Qe)throw new Error("End of Zip64 central directory locator not found");x==re&&(x=P(S,16)),c==re&&(c=P(S,20)),p==re&&(p=ye(S,32)),d==ie&&(d=ye(S,40)),f-=d}}if(f>=r.size&&(i=r.size-f-d-ae,f=r.size-d-ae),z!=x)throw new Error(ht);if(f<0)throw new Error(Fe);let u=0,b=await N(r,f,d,c),y=B(b);if(d){const U=l.offset-d;if(P(y,u)!=Je&&f!=U){const v=f;f=U,i+=f-v,b=await N(r,f,d,c),y=B(b)}}const k=l.offset-f-(r.lastDiskOffset||0);if(d!=k&&k>=0&&(d=k,b=await N(r,f,d,c),y=B(b)),f<0||f>=r.size)throw new Error(Fe);const m=V(e,t,"filenameEncoding"),h=V(e,t,"commentEncoding");for(let U=0;U<p;U++){const v=new Jn(r,a,e.options);if(P(y,u)!=Je)throw new Error("Central directory header not found");Qt(v,y,u+6);const S=!!v.bitFlag.languageEncodingFlag,E=u+46,O=E+v.filenameLength,W=O+v.extraFieldLength,F=I(y,u+4),C=!0,j=b.subarray(E,O),K=I(y,u+32),T=W+K,R=b.subarray(W,T),M=S,L=S,Ie=!(16&~le(y,u+38)),Ne=P(y,u+42)+i;Object.assign(v,{versionMadeBy:F,msDosCompatible:C,compressedSize:0,uncompressedSize:0,commentLength:K,directory:Ie,offset:Ne,diskNumberStart:I(y,u+34),internalFileAttribute:I(y,u+36),externalFileAttribute:P(y,u+38),rawFilename:j,filenameUTF8:M,commentUTF8:L,rawExtraField:b.subarray(O,W)});const Ve=V(e,t,"decodeText")||me,qe=M?wt:m||_t,He=L?wt:h||_t;let _e=Ve(j,qe);_e===H&&(_e=me(j,qe));let ze=Ve(R,He);ze===H&&(ze=me(R,He)),Object.assign(v,{rawComment:R,filename:_e,comment:ze,directory:Ie||_e.endsWith("/")}),o=Math.max(Ne,o),await Xt(v,v,y,u+6),v.zipCrypto=v.encrypted&&!v.extraFieldAES;const Ae=new ft(v);Ae.getData=(Ze,Yt)=>v.getData(Ze,Ae,Yt),u=T;const{onprogress:Ke}=t;if(Ke)try{await Ke(U+1,p,new ft(v))}catch{}yield Ae}const A=V(e,t,"extractPrependedData"),D=V(e,t,"extractAppendedData");return A&&(e.prependedData=o>0?await N(r,0,o):new Uint8Array),e.comment=_?await N(r,w+ae,_):new Uint8Array,D&&(e.appendedData=g<r.size?await N(r,g,r.size-g):new Uint8Array),!0}async getEntries(t={}){const e=[];for await(const r of this.getEntriesGenerator(t))e.push(r);return e}async close(){}}class Jn{constructor(t,e,r){Object.assign(this,{reader:t,config:e,options:r})}async getData(t,e,r={}){const a=this,{reader:l,offset:s,diskNumberStart:d,extraFieldAES:f,compressionMethod:w,config:_,bitFlag:g,signature:x,rawLastModDate:z,uncompressedSize:c,compressedSize:p}=a,i=e.localDirectory={},o=B(await N(l,s,30,d));let u=V(a,r,"password"),b=V(a,r,"rawPassword");const y=V(a,r,"passThrough");if(u=u&&u.length&&u,b=b&&b.length&&b,f&&f.originalCompressionMethod!=99)throw new Error(dt);if(w!=0&&w!=8&&!y)throw new Error(dt);if(P(o,0)!=67324752)throw new Error("Local file header not found");Qt(i,o,4),i.rawExtraField=i.extraFieldLength?await N(l,s+30+i.filenameLength,i.extraFieldLength,d):new Uint8Array,await Xt(a,i,o,4,!0),Object.assign(e,{lastAccessDate:i.lastAccessDate,creationDate:i.creationDate});const k=a.encrypted&&i.encrypted&&!y,m=k&&!f;if(y||(e.zipCrypto=m),k){if(!m&&f.strength===H)throw new Error("Encryption method not supported");if(!u&&!b)throw new Error("File contains encrypted entry")}const h=s+30+i.filenameLength+i.extraFieldLength,A=p,D=l.readable;Object.assign(D,{diskNumberStart:d,offset:h,size:A});const U=V(a,r,"signal"),v=V(a,r,"checkPasswordOnly");v&&(t=new WritableStream),t=function(j){j.writable===H&&typeof j.next==we&&(j=new ut(j)),j instanceof WritableStream&&(j={writable:j});const{writable:K}=j;return K.size===H&&(K.size=0),j instanceof ut||Object.assign(j,{diskNumber:0,diskOffset:0,availableSize:1/0,maxSize:1/0}),j}(t),await ve(t,y?p:c);const{writable:S}=t,{onstart:E,onprogress:O,onend:W}=r,F={options:{codecType:jt,password:u,rawPassword:b,zipCrypto:m,encryptionStrength:f&&f.strength,signed:V(a,r,"checkSignature")&&!y,passwordVerification:m&&(g.dataDescriptor?z>>>8&255:x>>>24&255),signature:x,compressed:w!=0&&!y,encrypted:a.encrypted&&!y,useWebWorkers:V(a,r,"useWebWorkers"),useCompressionStream:V(a,r,"useCompressionStream"),transferStreams:V(a,r,"transferStreams"),checkPasswordOnly:v},config:_,streamOptions:{signal:U,size:A,onstart:E,onprogress:O,onend:W}};let C=0;try{({outputSize:C}=await Mn({readable:D,writable:S},F))}catch(j){if(!v||j.message!=Pe)throw j}finally{const j=V(a,r,"preventClose");S.size+=C,j||S.locked||await S.getWriter().close()}return v?H:t.getData?t.getData():S}}function Qt(n,t,e){const r=n.rawBitFlag=I(t,e+2),a=!(1&~r),l=P(t,e+6);Object.assign(n,{encrypted:a,version:I(t,e),bitFlag:{level:(6&r)>>1,dataDescriptor:!(8&~r),languageEncodingFlag:!(2048&~r)},rawLastModDate:l,lastModDate:Qn(l),filenameLength:I(t,e+22),extraFieldLength:I(t,e+24)})}async function Xt(n,t,e,r,a){const{rawExtraField:l}=t,s=t.extraField=new Map,d=B(new Uint8Array(l));let f=0;try{for(;f<l.length;){const o=I(d,f),u=I(d,f+2);s.set(o,{type:o,data:l.slice(f+4,f+4+u)}),f+=4+u}}catch{}const w=I(e,r+4);Object.assign(t,{signature:P(e,r+10),uncompressedSize:P(e,r+18),compressedSize:P(e,r+14)});const _=s.get(1);_&&(function(o,u){u.zip64=!0;const b=B(o.data),y=Zn.filter(([k,m])=>u[k]==m);for(let k=0,m=0;k<y.length;k++){const[h,A]=y[k];if(u[h]==A){const D=Gn[A];u[h]=o[h]=D.getValue(b,m),m+=D.bytes}else if(o[h])throw new Error(Kn)}}(_,t),t.extraFieldZip64=_);const g=s.get(28789);g&&(await bt(g,It,Nt,t,n),t.extraFieldUnicodePath=g);const x=s.get(25461);x&&(await bt(x,Vt,qt,t,n),t.extraFieldUnicodeComment=x);const z=s.get(39169);z?(function(o,u,b){const y=B(o.data),k=le(y,4);Object.assign(o,{vendorVersion:le(y,0),vendorId:le(y,2),strength:k,originalCompressionMethod:b,compressionMethod:I(y,5)}),u.compressionMethod=o.compressionMethod}(z,t,w),t.extraFieldAES=z):t.compressionMethod=w;const c=s.get(10);c&&(function(o,u){const b=B(o.data);let y,k=4;try{for(;k<o.data.length&&!y;){const m=I(b,k),h=I(b,k+2);m==1&&(y=o.data.slice(k+4,k+4+h)),k+=4+h}}catch{}try{if(y&&y.length==24){const m=B(y),h=m.getBigUint64(0,!0),A=m.getBigUint64(8,!0),D=m.getBigUint64(16,!0);Object.assign(o,{rawLastModDate:h,rawLastAccessDate:A,rawCreationDate:D});const U=Oe(h),v=Oe(A),S={lastModDate:U,lastAccessDate:v,creationDate:Oe(D)};Object.assign(o,S),Object.assign(u,S)}}catch{}}(c,t),t.extraFieldNTFS=c);const p=s.get(21589);p&&(function(o,u,b){const y=B(o.data),k=le(y,0),m=[],h=[];b?(1&~k||(m.push(Me),h.push(Le)),2&~k||(m.push(Gt),h.push(Vn)),4&~k||(m.push(Jt),h.push(qn))):o.data.length>=5&&(m.push(Me),h.push(Le));let A=1;m.forEach((D,U)=>{if(o.data.length>=A+4){const v=P(y,A);u[D]=o[D]=new Date(1e3*v);const S=h[U];o[S]=v}A+=4})}(p,t,a),t.extraFieldExtendedTimestamp=p);const i=s.get(6534);i&&(t.extraFieldUSDZ=i)}async function bt(n,t,e,r,a){const l=B(n.data),s=new xe;s.append(a[e]);const d=B(new Uint8Array(4));d.setUint32(0,s.get(),!0);const f=P(l,1);Object.assign(n,{version:le(l,0),[t]:me(n.data.subarray(5)),valid:!a.bitFlag.languageEncodingFlag&&f==P(d,0)}),n.valid&&(r[t]=n[t],r[t+"UTF8"]=!0)}function V(n,t,e){return t[e]===H?n.options[e]:t[e]}function Qn(n){const t=(4294901760&n)>>16,e=65535&n;try{return new Date(1980+((65024&t)>>9),((480&t)>>5)-1,31&t,(63488&e)>>11,(2016&e)>>5,2*(31&e),0)}catch{}}function Oe(n){return new Date(Number(n/BigInt(1e4)-BigInt(116444736e5)))}function le(n,t){return n.getUint8(t)}function I(n,t){return n.getUint16(t,!0)}function P(n,t){return n.getUint32(t,!0)}function ye(n,t){return Number(n.getBigUint64(t,!0))}function B(n){return new DataView(n.buffer)}fn({Inflate:function(n){const t=new pt,e=n&&n.chunkSize?Math.floor(2*n.chunkSize):131072,r=new Uint8Array(e);let a=!1;t.inflateInit(),t.next_out=r,this.append=function(l,s){const d=[];let f,w,_=0,g=0,x=0;if(l.length!==0){t.next_in_index=0,t.next_in=l,t.avail_in=l.length;do{if(t.next_out_index=0,t.avail_out=e,t.avail_in!==0||a||(t.next_in_index=0,a=!0),f=t.inflate(0),a&&f===-5){if(t.avail_in!==0)throw new Error("inflating: bad input")}else if(f!==0&&f!==1)throw new Error("inflating: "+t.msg);if((a||f===1)&&t.avail_in===l.length)throw new Error("inflating: bad input");t.next_out_index&&(t.next_out_index===e?d.push(new Uint8Array(r)):d.push(r.subarray(0,t.next_out_index))),x+=t.next_out_index,s&&t.next_in_index>0&&t.next_in_index!=_&&(s(t.next_in_index),_=t.next_in_index)}while(t.avail_in>0||t.avail_out===0);return d.length>1?(w=new Uint8Array(x),d.forEach(function(z){w.set(z,g),g+=z.length})):w=d[0]?new Uint8Array(d[0]):new Uint8Array,w}},this.flush=function(){t.inflateEnd()}}});export{Pn as BlobReader,Rn as BlobWriter,Xn as TextWriter,Yn as ZipReader,fn as configure};
//# sourceMappingURL=zip-w4eY6XnM.js.map
